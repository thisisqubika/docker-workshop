{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Docker - Gu\u00eda del Usuario Bienvenidos a la gu\u00eda para el usuario Docker. Su intenci\u00f3n es ser manual de referencia y gu\u00eda de aprendizaje b\u00e1sico, es decir llevar r\u00e1pidamente al uso de Docker sin demasiado \u00e9nfasis en fundamentos o explicaciones de por qu\u00e9 suceden las cosas. C\u00f3mo utilizar esta gu\u00eda Esta gu\u00eda est\u00e1 redactada en markdown y puede ser clonada a su disco para hacerle las modificaciones y mejoras que deseen. La gu\u00eda puede ser le\u00edda en forma secuencial o aleatorea, de acuerdo a las necesidades de cada uno A qui\u00e9n va dirigida esta gu\u00eda Inicialmente a cualquiera que est\u00e9 interesado en Docker. No es una gu\u00eda b\u00e1sica, a pesar que empieza desde usos b\u00e1sicos de Docker, se recomienda entender los conceptos de contenedores en Linux y, obviamente, comprender los principios y objetivos de Docker. Por eso, si no sabe lo que es Docker, se sugiere buscar material explicativo. Si ya sabe lo que es Docker, esta gu\u00eda lo acercar\u00e1 a su uso. Por el contrario, si es un usuario de Docker, posiblemente encontrar\u00e1 poco \u00fatil esta gu\u00eda, pero cada ficha tiene material adicional al que podr\u00e1 consultar. Qu\u00e9 se puede aprender con esta gu\u00eda A usar docker. Que docker es mucho m\u00e1s que esta gu\u00eda, y que vale la pena cada minuto invertido en aprenderlo. Que docker es muy divertido.","title":"Introducci\u00f3n"},{"location":"#docker-guia-del-usuario","text":"Bienvenidos a la gu\u00eda para el usuario Docker. Su intenci\u00f3n es ser manual de referencia y gu\u00eda de aprendizaje b\u00e1sico, es decir llevar r\u00e1pidamente al uso de Docker sin demasiado \u00e9nfasis en fundamentos o explicaciones de por qu\u00e9 suceden las cosas.","title":"Docker - Gu\u00eda del Usuario"},{"location":"#como-utilizar-esta-guia","text":"Esta gu\u00eda est\u00e1 redactada en markdown y puede ser clonada a su disco para hacerle las modificaciones y mejoras que deseen. La gu\u00eda puede ser le\u00edda en forma secuencial o aleatorea, de acuerdo a las necesidades de cada uno","title":"C\u00f3mo utilizar esta gu\u00eda"},{"location":"#a-quien-va-dirigida-esta-guia","text":"Inicialmente a cualquiera que est\u00e9 interesado en Docker. No es una gu\u00eda b\u00e1sica, a pesar que empieza desde usos b\u00e1sicos de Docker, se recomienda entender los conceptos de contenedores en Linux y, obviamente, comprender los principios y objetivos de Docker. Por eso, si no sabe lo que es Docker, se sugiere buscar material explicativo. Si ya sabe lo que es Docker, esta gu\u00eda lo acercar\u00e1 a su uso. Por el contrario, si es un usuario de Docker, posiblemente encontrar\u00e1 poco \u00fatil esta gu\u00eda, pero cada ficha tiene material adicional al que podr\u00e1 consultar.","title":"A qui\u00e9n va dirigida esta gu\u00eda"},{"location":"#que-se-puede-aprender-con-esta-guia","text":"A usar docker. Que docker es mucho m\u00e1s que esta gu\u00eda, y que vale la pena cada minuto invertido en aprenderlo. Que docker es muy divertido.","title":"Qu\u00e9 se puede aprender con esta gu\u00eda"},{"location":"about/","text":"Sobre esta gu\u00eda Licencia La presente gu\u00eda se recibe con licencia Creative Commons de Atribuci\u00f3n y de compartir en las mismas condiciones. Creative Commons Attribution Share Alike 4.0 International Esta gu\u00eda puede ser utilizada con fines comerciales, puede ser modificada, est\u00e1 permitido distribuir las modificaciones y tambi\u00e9n se permite el uso privado. Historia Esta gu\u00eda se comenz\u00f3 a escribir en el mes de julio de 2018 y es un trabajo en proceso.","title":"Sobre esta gu\u00eda"},{"location":"about/#sobre-esta-guia","text":"","title":"Sobre esta gu\u00eda"},{"location":"about/#licencia","text":"La presente gu\u00eda se recibe con licencia Creative Commons de Atribuci\u00f3n y de compartir en las mismas condiciones. Creative Commons Attribution Share Alike 4.0 International Esta gu\u00eda puede ser utilizada con fines comerciales, puede ser modificada, est\u00e1 permitido distribuir las modificaciones y tambi\u00e9n se permite el uso privado.","title":"Licencia"},{"location":"about/#historia","text":"Esta gu\u00eda se comenz\u00f3 a escribir en el mes de julio de 2018 y es un trabajo en proceso.","title":"Historia"},{"location":"chapter01/01funciona/","text":"C\u00f3mo funciona docker Introducci\u00f3n Generalmente docker (o contenedores) se explican a trav\u00e9s de las diferencias entre virtualizaci\u00f3n y contenedores y destacando los pro y contras de cada uno de ellos. Los contenedores es un m\u00e9todo de encapsular o aislar, a nivel de kernel, procesos y recursos en el sistema operativo de forma que no tengan contacto o posibilidad de conocer otros contenedores que est\u00e1n corriendo sobre el mismo sistema operativo. Contenedores se construyen a trav\u00e9s de m\u00e9todos de aislamiento (chroot, labels, virtual networks, etc) que hacen que los comandos que se ejecuten en el contenedor (ps, top, ip, free, ls, etc.) solo tengan acceso a los recursos asignados al contenedor y no llegan a ver los del sistema operativo principal ni los de otros contenedores. Docker es una implementaci\u00f3n de las funcionalidades de contenedores para sistemas GNU/Linux que tiene como objetivo facilitar la creaci\u00f3n, uso y la posibilidad de compartir los contenedores creados, de forma que no solo se pueden levantar en un sistema, sino que pueden ejecutarse en multiples equipos e, inclusive, distribuciones de Linux. Las im\u00e1genes de docker es la forma en que se comparten los contenedores, mediante repositorios de im\u00e1genes llamados Registry a los que se accede para obtener im\u00e1genes con distinto grado de personalizaci\u00f3n que se utilizan para correr aplicaciones en distintos sistemas. Los docker en cuanto contenedores representan un est\u00e1ndar que permite compartir aplicaciones para poner a correr en distintos sistemas con un m\u00ednimo de esfuerzo de instalaci\u00f3n y ocupando los recursos que requiera la aplicaci\u00f3n, con un m\u00ednimo de sobrecarga de construcci\u00f3n o mantenimiento. De esta forma docker ha evolucionado a conceptos de m\u00e1xima aislaci\u00f3n entre procesos (Microservicios) y ejecuci\u00f3n paralela de varias instancias iguales (Cluster). Tecnolog\u00eda Docker est\u00e1 escrito en el lenguaje GO y permite configurar el kernel Linux para construir y mantener los contenedores. Namespaces Los contenedores utiliza namespaces (etiquetas) para aislar el contenedor. El ejecutar un contenedor se crea una etiqueta que identificar\u00e1: PID - Aislaci\u00f3n de procesos. NET - Aislaci\u00f3n de interfaces de red, rutas, reglas de filtrado, etc. IPC - Recursos IPC (InterProcess Communication). MNT - Puntos de montado del filesystem UTS - Aislaci\u00f3n de kernel e identificadores de versi\u00f3n (UTS: Unix Timesharing System). CGroups Los control groups permiten limitar el acceso a determinados recursos. Mediante los cgroups el kernel permitir\u00e1 compartir recursos reales a los containers y les establecer\u00e1 l\u00edmites de uso. Union filesystem El filesystem Union (UnionFS) permite crear capas de modificaciones. Docker utiliza UnionFS para optimizar los bloques y las im\u00e1genes que crean los contenedores. Container format Docker Engine combina estos elementos (namespaces, cgroups y UnionFS) para crear un entorno llamado container format . El container format por defecto se llama libcontainer , que se usa sobre sistemas GNU/Linux. En un futuro Docker puede soportar otros formatos de container que permitir\u00e1n incorporarlo a otros sistemas como BSD o Solaris. Referencias: https://docs.docker.com/engine/docker-overview/","title":"C\u00f3mo funciona docker"},{"location":"chapter01/01funciona/#como-funciona-docker","text":"","title":"C\u00f3mo funciona docker"},{"location":"chapter01/01funciona/#introduccion","text":"Generalmente docker (o contenedores) se explican a trav\u00e9s de las diferencias entre virtualizaci\u00f3n y contenedores y destacando los pro y contras de cada uno de ellos. Los contenedores es un m\u00e9todo de encapsular o aislar, a nivel de kernel, procesos y recursos en el sistema operativo de forma que no tengan contacto o posibilidad de conocer otros contenedores que est\u00e1n corriendo sobre el mismo sistema operativo. Contenedores se construyen a trav\u00e9s de m\u00e9todos de aislamiento (chroot, labels, virtual networks, etc) que hacen que los comandos que se ejecuten en el contenedor (ps, top, ip, free, ls, etc.) solo tengan acceso a los recursos asignados al contenedor y no llegan a ver los del sistema operativo principal ni los de otros contenedores. Docker es una implementaci\u00f3n de las funcionalidades de contenedores para sistemas GNU/Linux que tiene como objetivo facilitar la creaci\u00f3n, uso y la posibilidad de compartir los contenedores creados, de forma que no solo se pueden levantar en un sistema, sino que pueden ejecutarse en multiples equipos e, inclusive, distribuciones de Linux. Las im\u00e1genes de docker es la forma en que se comparten los contenedores, mediante repositorios de im\u00e1genes llamados Registry a los que se accede para obtener im\u00e1genes con distinto grado de personalizaci\u00f3n que se utilizan para correr aplicaciones en distintos sistemas. Los docker en cuanto contenedores representan un est\u00e1ndar que permite compartir aplicaciones para poner a correr en distintos sistemas con un m\u00ednimo de esfuerzo de instalaci\u00f3n y ocupando los recursos que requiera la aplicaci\u00f3n, con un m\u00ednimo de sobrecarga de construcci\u00f3n o mantenimiento. De esta forma docker ha evolucionado a conceptos de m\u00e1xima aislaci\u00f3n entre procesos (Microservicios) y ejecuci\u00f3n paralela de varias instancias iguales (Cluster).","title":"Introducci\u00f3n"},{"location":"chapter01/01funciona/#tecnologia","text":"Docker est\u00e1 escrito en el lenguaje GO y permite configurar el kernel Linux para construir y mantener los contenedores.","title":"Tecnolog\u00eda"},{"location":"chapter01/01funciona/#namespaces","text":"Los contenedores utiliza namespaces (etiquetas) para aislar el contenedor. El ejecutar un contenedor se crea una etiqueta que identificar\u00e1: PID - Aislaci\u00f3n de procesos. NET - Aislaci\u00f3n de interfaces de red, rutas, reglas de filtrado, etc. IPC - Recursos IPC (InterProcess Communication). MNT - Puntos de montado del filesystem UTS - Aislaci\u00f3n de kernel e identificadores de versi\u00f3n (UTS: Unix Timesharing System).","title":"Namespaces"},{"location":"chapter01/01funciona/#cgroups","text":"Los control groups permiten limitar el acceso a determinados recursos. Mediante los cgroups el kernel permitir\u00e1 compartir recursos reales a los containers y les establecer\u00e1 l\u00edmites de uso.","title":"CGroups"},{"location":"chapter01/01funciona/#union-filesystem","text":"El filesystem Union (UnionFS) permite crear capas de modificaciones. Docker utiliza UnionFS para optimizar los bloques y las im\u00e1genes que crean los contenedores.","title":"Union filesystem"},{"location":"chapter01/01funciona/#container-format","text":"Docker Engine combina estos elementos (namespaces, cgroups y UnionFS) para crear un entorno llamado container format . El container format por defecto se llama libcontainer , que se usa sobre sistemas GNU/Linux. En un futuro Docker puede soportar otros formatos de container que permitir\u00e1n incorporarlo a otros sistemas como BSD o Solaris.","title":"Container format"},{"location":"chapter01/01funciona/#referencias","text":"https://docs.docker.com/engine/docker-overview/","title":"Referencias:"},{"location":"chapter01/02verificar/","text":"Verificaci\u00f3n de la instalaci\u00f3n No es un objetivo de esta gu\u00eda abordar la instalaci\u00f3n de docker . Si bien la instalaci\u00f3n es un proceso sencillo, los requisitos y opciones de configuraci\u00f3n var\u00edan seg\u00fan d\u00f3nde se va a utilizar docker. Docker es nativo de sistemas operativos Linux y los procesos de instalaci\u00f3n difieren de acuerdo a la distribuci\u00f3n y versi\u00f3n de Linux que se use. Pero en la actualidad, docker se puede instalar en otros sistemas operativos como macOS y Windows . Verificaci\u00f3n de la instalaci\u00f3n Primero es consultar la versi\u00f3n instalada de docker: $ docker version Muestra versi\u00f3n del cliente y versi\u00f3n del servidor (si est\u00e1 corriendo): Client: Version: 18.03.1-ce API version: 1.37 Go version: go1.9.5 Git commit: 9ee9f40 Built: Thu Apr 26 07:17:20 2018 OS/Arch: linux/amd64 Experimental: false Orchestrator: swarm Server: Engine: Version: 18.03.1-ce API version: 1.37 (minimum version 1.12) Go version: go1.9.5 Git commit: 9ee9f40 Built: Thu Apr 26 07:15:30 2018 OS/Arch: linux/amd64 Experimental: false Est\u00e1 corriendo el daemon Docker Engine ( Server ) que ejecuta (crea) y mantiene los contenedores. Adem\u00e1s, dispone de un cliente que es el comando docker propiamente dicho. Y seguidamente con el comando $ docker system info saber c\u00f3mo est\u00e1 docker funcionando en nuestro sistema (los datos mostrados pueden variar): Containers: 0 Running: 0 Paused: 0 Stopped: 0 Images: 0 Server Version: 18.03.1-ce Storage Driver: overlay2 Backing Filesystem: extfs Supports d_type: true Native Overlay Diff: true Logging Driver: json-file Cgroup Driver: cgroupfs Plugins: Volume: local Network: bridge host macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file logentries splunk syslog Swarm: inactive Runtimes: runc Default Runtime: runc Init Binary: docker-init containerd version: 773c489c9c1b21a6d78b5c538cd395416ec50f88 runc version: 4fc53a81fb7c994640722ac585fa9ca548971871 init version: 949e6fa Security Options: apparmor seccomp Profile: default Kernel Version: 4.4.0-127-generic Operating System: Ubuntu 16.04.4 LTS OSType: linux Architecture: x86_64 CPUs: 1 Total Memory: 992.2MiB Name: server ID: ILHX:XLTM:6XDZ:FUYB:DY7I:ETMT:J4BQ:7XQ6:5MPY:TD6X:7M6L:NZE7 Docker Root Dir: /var/lib/docker Debug Mode (client): false Debug Mode (server): false Registry: https://index.docker.io/v1/ Labels: Experimental: false Insecure Registries: 127.0.0.0/8 Live Restore Enabled: false Es posible ejecutar un primer contenedor para verificar los el funcionamiento Docker Engine : Registry Network CGroups System etc. $ docker run --rm hello-world Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ $","title":"Verificaci\u00f3n de la instalaci\u00f3n"},{"location":"chapter01/02verificar/#verificacion-de-la-instalacion","text":"No es un objetivo de esta gu\u00eda abordar la instalaci\u00f3n de docker . Si bien la instalaci\u00f3n es un proceso sencillo, los requisitos y opciones de configuraci\u00f3n var\u00edan seg\u00fan d\u00f3nde se va a utilizar docker. Docker es nativo de sistemas operativos Linux y los procesos de instalaci\u00f3n difieren de acuerdo a la distribuci\u00f3n y versi\u00f3n de Linux que se use. Pero en la actualidad, docker se puede instalar en otros sistemas operativos como macOS y Windows .","title":"Verificaci\u00f3n de la instalaci\u00f3n"},{"location":"chapter01/02verificar/#verificacion-de-la-instalacion_1","text":"Primero es consultar la versi\u00f3n instalada de docker: $ docker version Muestra versi\u00f3n del cliente y versi\u00f3n del servidor (si est\u00e1 corriendo): Client: Version: 18.03.1-ce API version: 1.37 Go version: go1.9.5 Git commit: 9ee9f40 Built: Thu Apr 26 07:17:20 2018 OS/Arch: linux/amd64 Experimental: false Orchestrator: swarm Server: Engine: Version: 18.03.1-ce API version: 1.37 (minimum version 1.12) Go version: go1.9.5 Git commit: 9ee9f40 Built: Thu Apr 26 07:15:30 2018 OS/Arch: linux/amd64 Experimental: false Est\u00e1 corriendo el daemon Docker Engine ( Server ) que ejecuta (crea) y mantiene los contenedores. Adem\u00e1s, dispone de un cliente que es el comando docker propiamente dicho. Y seguidamente con el comando $ docker system info saber c\u00f3mo est\u00e1 docker funcionando en nuestro sistema (los datos mostrados pueden variar): Containers: 0 Running: 0 Paused: 0 Stopped: 0 Images: 0 Server Version: 18.03.1-ce Storage Driver: overlay2 Backing Filesystem: extfs Supports d_type: true Native Overlay Diff: true Logging Driver: json-file Cgroup Driver: cgroupfs Plugins: Volume: local Network: bridge host macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file logentries splunk syslog Swarm: inactive Runtimes: runc Default Runtime: runc Init Binary: docker-init containerd version: 773c489c9c1b21a6d78b5c538cd395416ec50f88 runc version: 4fc53a81fb7c994640722ac585fa9ca548971871 init version: 949e6fa Security Options: apparmor seccomp Profile: default Kernel Version: 4.4.0-127-generic Operating System: Ubuntu 16.04.4 LTS OSType: linux Architecture: x86_64 CPUs: 1 Total Memory: 992.2MiB Name: server ID: ILHX:XLTM:6XDZ:FUYB:DY7I:ETMT:J4BQ:7XQ6:5MPY:TD6X:7M6L:NZE7 Docker Root Dir: /var/lib/docker Debug Mode (client): false Debug Mode (server): false Registry: https://index.docker.io/v1/ Labels: Experimental: false Insecure Registries: 127.0.0.0/8 Live Restore Enabled: false Es posible ejecutar un primer contenedor para verificar los el funcionamiento Docker Engine : Registry Network CGroups System etc. $ docker run --rm hello-world Hello from Docker! This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. (amd64) 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker ID: https://hub.docker.com/ For more examples and ideas, visit: https://docs.docker.com/get-started/ $","title":"Verificaci\u00f3n de la instalaci\u00f3n"},{"location":"chapter01/03vagrant/","text":"Instalaci\u00f3n con Vagrant En el repositorio se dispone de un archivo Vagrantfile . Requisitos Virtualbox Virtualbox Extension Pack Vagrant Ejecuci\u00f3n $ vagrant up Bringing machine 'dkrworkshop' up with 'virtualbox' provider... ... ... dkrworkshop: Processing triggers for libc-bin (2.27-3ubuntu1) ... $ $ vagrant ssh Welcome to Ubuntu 18.04.2 LTS (GNU/Linux 4.15.0-45-generic x86_64) ... vagrant@dkrworkshop:~$","title":"Instalaci\u00f3n con Vagrant"},{"location":"chapter01/03vagrant/#instalacion-con-vagrant","text":"En el repositorio se dispone de un archivo Vagrantfile .","title":"Instalaci\u00f3n con Vagrant"},{"location":"chapter01/03vagrant/#requisitos","text":"Virtualbox Virtualbox Extension Pack Vagrant","title":"Requisitos"},{"location":"chapter01/03vagrant/#ejecucion","text":"$ vagrant up Bringing machine 'dkrworkshop' up with 'virtualbox' provider... ... ... dkrworkshop: Processing triggers for libc-bin (2.27-3ubuntu1) ... $ $ vagrant ssh Welcome to Ubuntu 18.04.2 LTS (GNU/Linux 4.15.0-45-generic x86_64) ... vagrant@dkrworkshop:~$","title":"Ejecuci\u00f3n"},{"location":"chapter01/","text":"Generalidades de docker La instalaci\u00f3n de docker no est\u00e1 cubierta por esta gu\u00eda. Instalaci\u00f3n con Vagrant Install docker desktop on Mac (external) Install docker-compose (external) Continuaci\u00f3n: Verificaci\u00f3n de la instalaci\u00f3n C\u00f3mo funciona docker","title":"Generalidades de docker"},{"location":"chapter01/#generalidades-de-docker","text":"La instalaci\u00f3n de docker no est\u00e1 cubierta por esta gu\u00eda. Instalaci\u00f3n con Vagrant Install docker desktop on Mac (external) Install docker-compose (external) Continuaci\u00f3n: Verificaci\u00f3n de la instalaci\u00f3n C\u00f3mo funciona docker","title":"Generalidades de docker"},{"location":"chapter02/01autoejecutable/","text":"Docker autoejecutable Cuando utilizamos docker para correr una imagen que ya tiene un proceso configurado decimos que ejecutamos un proceso docketizado . $ docker container run hello-world Al ejecutar buscar\u00e1 localmente una imagen llamada hello-world , no la encontrar\u00e1 proceder\u00e1 a descargarla y guardarla en el registry local: Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 9bb5a5d4561a: Pull complete Digest: sha256:f5233545e43561214ca4891fd1157e1c3c563316ed8e237750d59bde73361e77 Status: Downloaded newer image for hello-world:latest Seguidamente correr\u00e1 el proceso que posee la imagen y producir\u00e1 la siguiente salida: Hello from Docker. This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker Hub account: https://hub.docker.com For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ Esta imagen ha sido creada con el \u00fanico fin de correr ese proceso docketizado que exclusivamente muestra ese texto. Ejercicios 1. Vuelva a ejecutar la imagen hello-world y preste atenci\u00f3n a que ahora no ser\u00e1 descargada, sino que se levantar\u00e1 directamente desde el repositorio local 2. Liste las im\u00e1genes con el comando docker image ls Preste atenci\u00f3n al tama\u00f1o que ocupa en el disco Referencias: Im\u00e1gen hello-world","title":"Docker autoejecutable"},{"location":"chapter02/01autoejecutable/#docker-autoejecutable","text":"Cuando utilizamos docker para correr una imagen que ya tiene un proceso configurado decimos que ejecutamos un proceso docketizado . $ docker container run hello-world Al ejecutar buscar\u00e1 localmente una imagen llamada hello-world , no la encontrar\u00e1 proceder\u00e1 a descargarla y guardarla en el registry local: Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 9bb5a5d4561a: Pull complete Digest: sha256:f5233545e43561214ca4891fd1157e1c3c563316ed8e237750d59bde73361e77 Status: Downloaded newer image for hello-world:latest Seguidamente correr\u00e1 el proceso que posee la imagen y producir\u00e1 la siguiente salida: Hello from Docker. This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker Hub account: https://hub.docker.com For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ Esta imagen ha sido creada con el \u00fanico fin de correr ese proceso docketizado que exclusivamente muestra ese texto.","title":"Docker autoejecutable"},{"location":"chapter02/01autoejecutable/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter02/01autoejecutable/#1","text":"Vuelva a ejecutar la imagen hello-world y preste atenci\u00f3n a que ahora no ser\u00e1 descargada, sino que se levantar\u00e1 directamente desde el repositorio local","title":"1."},{"location":"chapter02/01autoejecutable/#2","text":"Liste las im\u00e1genes con el comando docker image ls Preste atenci\u00f3n al tama\u00f1o que ocupa en el disco","title":"2."},{"location":"chapter02/01autoejecutable/#referencias","text":"Im\u00e1gen hello-world","title":"Referencias:"},{"location":"chapter02/02comando/","text":"Docker como comando Tambi\u00e9n podemos tomar una imagen cualquiera, aunque tenga una aplicaci\u00f3n instalada y ejecutar comandos en ella: $ docker container run busybox echo 'hola mundo!' La primera vez que lo ejecutamos, descargar\u00e1 la imagen busybox e inmediatamente ejecutar\u00e1 el comando echo 'hola mundo!' produciendo la salida correspondiente: Unable to find image 'busybox:latest' locally latest: Pulling from busybox 920777304d1d: Pull complete 437595becdeb: Pull complete Digest: sha256:4a731fb46adc5cefe3ae374a8b6020fce9 Status: Downloaded newer image for busybox:latest hola mundo! A partir de tener la imagen busybox local, podemos ejecutar otros comandos con ella: $ docker container run busybox ps xa PID USER TIME COMMAND 1 root 0:00 ps xa Para saber por qu\u00e9 tenemos un \u00fanico proceso con PID 1 , ver C\u00f3mo funciona docker Cada vez que ejecutamos una imagen , queda guardado el contenedor ejecutado, es decir no se borra: $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d223748120dc busybox \"echo 'hola mundo!'\" 17 seconds ago Exited (0) 16 seconds ago mystifying_heyrovsky 4018dd3cdd71 hello-world \"/hello\" 21 minutes ago Exited (0) 21 minutes ago vigorous_shannon Ejercicios 1. Ejecute los siguientes comandos con imagen alpine : ls -l cat /etc/alpine-release ps axu 2. Compare la salida del comando mount ejecutado en el sistema GNU/Linux y dentro de un contenedor (por ej. con la imagen alpine ). Note la diferencia del directorio / montado en el contenedor y en el sistema externo . 3. Encuentre la diferencia entre ejecutar el comando man en las im\u00e1genes de alpine y busybox . 4. Utilizando la imagen ruby:latest ejecutar c\u00f3digo ruby: docker run --rm ruby ruby -e 'print \"Hello Ruby!\\n\"' Referencias: Im\u00e1gen busybox","title":"Docker como comando"},{"location":"chapter02/02comando/#docker-como-comando","text":"Tambi\u00e9n podemos tomar una imagen cualquiera, aunque tenga una aplicaci\u00f3n instalada y ejecutar comandos en ella: $ docker container run busybox echo 'hola mundo!' La primera vez que lo ejecutamos, descargar\u00e1 la imagen busybox e inmediatamente ejecutar\u00e1 el comando echo 'hola mundo!' produciendo la salida correspondiente: Unable to find image 'busybox:latest' locally latest: Pulling from busybox 920777304d1d: Pull complete 437595becdeb: Pull complete Digest: sha256:4a731fb46adc5cefe3ae374a8b6020fce9 Status: Downloaded newer image for busybox:latest hola mundo! A partir de tener la imagen busybox local, podemos ejecutar otros comandos con ella: $ docker container run busybox ps xa PID USER TIME COMMAND 1 root 0:00 ps xa Para saber por qu\u00e9 tenemos un \u00fanico proceso con PID 1 , ver C\u00f3mo funciona docker Cada vez que ejecutamos una imagen , queda guardado el contenedor ejecutado, es decir no se borra: $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d223748120dc busybox \"echo 'hola mundo!'\" 17 seconds ago Exited (0) 16 seconds ago mystifying_heyrovsky 4018dd3cdd71 hello-world \"/hello\" 21 minutes ago Exited (0) 21 minutes ago vigorous_shannon","title":"Docker como comando"},{"location":"chapter02/02comando/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter02/02comando/#1","text":"Ejecute los siguientes comandos con imagen alpine : ls -l cat /etc/alpine-release ps axu","title":"1."},{"location":"chapter02/02comando/#2","text":"Compare la salida del comando mount ejecutado en el sistema GNU/Linux y dentro de un contenedor (por ej. con la imagen alpine ). Note la diferencia del directorio / montado en el contenedor y en el sistema externo .","title":"2."},{"location":"chapter02/02comando/#3","text":"Encuentre la diferencia entre ejecutar el comando man en las im\u00e1genes de alpine y busybox .","title":"3."},{"location":"chapter02/02comando/#4","text":"Utilizando la imagen ruby:latest ejecutar c\u00f3digo ruby: docker run --rm ruby ruby -e 'print \"Hello Ruby!\\n\"'","title":"4."},{"location":"chapter02/02comando/#referencias","text":"Im\u00e1gen busybox","title":"Referencias:"},{"location":"chapter02/03shell/","text":"Docker como shell Podemos ingresar al contenedor docker para ejecutar los comandos que est\u00e9n disponibles en la imagen que utilizamos para correrlo. $ docker run -it debian bash donde: -i crea una sesi\u00f3n interactiva -t ofrece una terminal (tty) y la imagen que utilizar\u00e1 es un debian m\u00ednimo y ejecutar\u00e1 el comando bash , dando como resultado un shell: root@ce1a1c7bf990:/# root@ce1a1c7bf990:/# pwd / root@ce1a1c7bf990:/# ps ax PID TTY STAT TIME COMMAND 1 ? Ss 0:00 bash 6 ? R+ 0:00 ps ax root@ce1a1c7bf990:/# exit exit Ejercicios 1. Utilizamos la funcionalidad interactiva para verificar la aislaci\u00f3n entre contenedores, ejecute los siguientes comandos: docker container run -it alpine /bin/ash echo \"hello world\" > hello.txt ls exit Ejecutar un segundo contenedor y listamos su contenido docker container run alpine ls Busque el container que ha ejecutado con /bin/ash docker container ls -a | grep ash e in\u00edcielo nuevamente docker container start <container ID> en el container que acaba de iniciar ejecute un comando con la opci\u00f3n exec docker container exec <container ID> ls 2. Del ejercicio anterior entienda bien al diferencia entre las opciones exec y run 3. Utilizar la imagen ruby:latest para ejecutar irb Referencias: Im\u00e1gen debian Im\u00e1gen alpine","title":"Docker como shell"},{"location":"chapter02/03shell/#docker-como-shell","text":"Podemos ingresar al contenedor docker para ejecutar los comandos que est\u00e9n disponibles en la imagen que utilizamos para correrlo. $ docker run -it debian bash donde: -i crea una sesi\u00f3n interactiva -t ofrece una terminal (tty) y la imagen que utilizar\u00e1 es un debian m\u00ednimo y ejecutar\u00e1 el comando bash , dando como resultado un shell: root@ce1a1c7bf990:/# root@ce1a1c7bf990:/# pwd / root@ce1a1c7bf990:/# ps ax PID TTY STAT TIME COMMAND 1 ? Ss 0:00 bash 6 ? R+ 0:00 ps ax root@ce1a1c7bf990:/# exit exit","title":"Docker como shell"},{"location":"chapter02/03shell/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter02/03shell/#1","text":"Utilizamos la funcionalidad interactiva para verificar la aislaci\u00f3n entre contenedores, ejecute los siguientes comandos: docker container run -it alpine /bin/ash echo \"hello world\" > hello.txt ls exit Ejecutar un segundo contenedor y listamos su contenido docker container run alpine ls Busque el container que ha ejecutado con /bin/ash docker container ls -a | grep ash e in\u00edcielo nuevamente docker container start <container ID> en el container que acaba de iniciar ejecute un comando con la opci\u00f3n exec docker container exec <container ID> ls","title":"1."},{"location":"chapter02/03shell/#2","text":"Del ejercicio anterior entienda bien al diferencia entre las opciones exec y run","title":"2."},{"location":"chapter02/03shell/#3","text":"Utilizar la imagen ruby:latest para ejecutar irb","title":"3."},{"location":"chapter02/03shell/#referencias","text":"Im\u00e1gen debian Im\u00e1gen alpine","title":"Referencias:"},{"location":"chapter02/04servicio/","text":"Docker como servicio Poner a correr una imagen docker cuyo proceso es un servicio supone dejar corriendo algo en forma permanente para utilizar el servicio. Al poner algo a correr en forma permanente debemos, adem\u00e1s de saber c\u00f3mo ejecutarlo, saber si est\u00e1 funcionando, utilizar el servicio y c\u00f3mo apagarlo, as\u00ed que este paso involucra algunos conceptos m\u00e1s del uso de docker. Simple-webserver La imagen andygrunwald/simple-webserver es un webserver simple escrito en Go. RUN $ docker run -d -p 8082:8082 andygrunwald/simple-webserver donde: -d pondr\u00e1 a correr el docker en //background// -p 8082:8082 abrir\u00e1 el puerto 8082 en el equipo local conectar\u00e1 con el puerto 8082 del contenedor. y descargar\u00e1 la imagen y nos devolver\u00e1 el prompt , pero ha dejado corriendo el docker. LS Podemos interrogar con docker si el contenedor est\u00e1 corriendo: $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8d5297a02f2c andygrunwald/simple-webserver \"app\" About a minute ago Up About a minute 0.0.0.0:8082->8082/tcp stupefied_bohr docker container ls es equivalente a docker ps Utilizar el servicio El servicio es un servidor web simple que lo podemos ver con el navegador conectando al puerto local, que configuramos con -p , mediante el comando curl : $ curl http://localhost:8082/version simple webserver v1.0.0 STOP - KILL Como al contenedor lo creamos sin nombre, nos referimos a \u00e9l por el Container ID y lo apagamos con STOP : $ docker container stop 01a420094251 $ docker container ls CONTAINER ID IMAGE COMMAND $ docker stop env\u00eda las se\u00f1ales SIGTERM y luego SYGKILL a los procesos del contenedor El comando docker container kill <container-id> env\u00eda por defecto la se\u00f1al SIGKILL y soporta otras se\u00f1ales. START $ docker container start 01a420094251 EXEC Es posible acceder a un contenedor, para modificar contenido, revisar logs, verificar distintas configuraciones, obteniendo shell: docker container exec -it stupefied_bohr sh donde: -i entrar\u00e1 en modo interactivo -t asignara una consola tty al proceso ejecutado (sh) Servidor SSH La imagen tutum/debian levanta en un contenedor un servicio OpenSSH. RUN $ docker run -d -p 2222:22 tutum/debian EXEC Consultar la configuraci\u00f3n que qued\u00f3 levantada para el acceso ssh: $ docker container logs 3a49c40eee76 => Setting a random password to the root user => Done! ======================================================================== You can now connect to this Debian container via SSH using: ssh -p <port> root@<host> and enter the root password 'vVuzz8JcvafD' when prompted Please remember to change the above password as soon as possible! ======================================================================== Utilizar servicio $ ssh -p 2222 root@127.0.0.1 STOP -> RM docker container rm permite borrar los contenedores apagados ( stop ) \u00fanicamente. $ docker container rm Error response from daemon: You cannot remove a running container 3a49c40eee762a5887ba2d11dd801c98a7b8c22031ca049f1022f2f2ab9ca745. Stop the container before attempting removal or force remove $ docker container stop 3a49c40eee76 3a49c40eee76 $ docker container rm 3a49c40eee76 3a49c40eee76 PRUNE docker container prune borra todos los contenedores que est\u00e1n detenidos. Ejercicios 1. Borrar todos los container apagados utilizando los comandos: docker container ps -a docker container rm <CONTAINER-ID> 2. Volver a ejecutar el container ( Simple-webserver )como se muestra a principio esta secci\u00f3n verificando que est\u00e9 activo y tratar de borrarlo con los comandos, verificando las diferencias entre ellos: docker container rm <CONTAINER-ID> docker container rm -f <CONTAINER-ID> 3. Volver a ejecutar el container ( Simple-webserver ) pero esta vez sin el par\u00e1metro -d dejando el servicio en primer plano. Desde otra consola hacer conexiones con curl http://localhost:8082 Salir con Ctrl-C y verificar qu\u00e9 sucede con el contenedor utilizando el comando docker container ls Referencias: docker container docker run Im\u00e1gen andygrunwald/simple-webserver Im\u00e1gen tutum/debian","title":"Docker como servicio"},{"location":"chapter02/04servicio/#docker-como-servicio","text":"Poner a correr una imagen docker cuyo proceso es un servicio supone dejar corriendo algo en forma permanente para utilizar el servicio. Al poner algo a correr en forma permanente debemos, adem\u00e1s de saber c\u00f3mo ejecutarlo, saber si est\u00e1 funcionando, utilizar el servicio y c\u00f3mo apagarlo, as\u00ed que este paso involucra algunos conceptos m\u00e1s del uso de docker.","title":"Docker como servicio"},{"location":"chapter02/04servicio/#simple-webserver","text":"La imagen andygrunwald/simple-webserver es un webserver simple escrito en Go.","title":"Simple-webserver"},{"location":"chapter02/04servicio/#run","text":"$ docker run -d -p 8082:8082 andygrunwald/simple-webserver donde: -d pondr\u00e1 a correr el docker en //background// -p 8082:8082 abrir\u00e1 el puerto 8082 en el equipo local conectar\u00e1 con el puerto 8082 del contenedor. y descargar\u00e1 la imagen y nos devolver\u00e1 el prompt , pero ha dejado corriendo el docker.","title":"RUN"},{"location":"chapter02/04servicio/#ls","text":"Podemos interrogar con docker si el contenedor est\u00e1 corriendo: $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8d5297a02f2c andygrunwald/simple-webserver \"app\" About a minute ago Up About a minute 0.0.0.0:8082->8082/tcp stupefied_bohr docker container ls es equivalente a docker ps","title":"LS"},{"location":"chapter02/04servicio/#utilizar-el-servicio","text":"El servicio es un servidor web simple que lo podemos ver con el navegador conectando al puerto local, que configuramos con -p , mediante el comando curl : $ curl http://localhost:8082/version simple webserver v1.0.0","title":"Utilizar el servicio"},{"location":"chapter02/04servicio/#stop-kill","text":"Como al contenedor lo creamos sin nombre, nos referimos a \u00e9l por el Container ID y lo apagamos con STOP : $ docker container stop 01a420094251 $ docker container ls CONTAINER ID IMAGE COMMAND $ docker stop env\u00eda las se\u00f1ales SIGTERM y luego SYGKILL a los procesos del contenedor El comando docker container kill <container-id> env\u00eda por defecto la se\u00f1al SIGKILL y soporta otras se\u00f1ales.","title":"STOP - KILL"},{"location":"chapter02/04servicio/#start","text":"$ docker container start 01a420094251","title":"START"},{"location":"chapter02/04servicio/#exec","text":"Es posible acceder a un contenedor, para modificar contenido, revisar logs, verificar distintas configuraciones, obteniendo shell: docker container exec -it stupefied_bohr sh donde: -i entrar\u00e1 en modo interactivo -t asignara una consola tty al proceso ejecutado (sh)","title":"EXEC"},{"location":"chapter02/04servicio/#servidor-ssh","text":"La imagen tutum/debian levanta en un contenedor un servicio OpenSSH.","title":"Servidor SSH"},{"location":"chapter02/04servicio/#run_1","text":"$ docker run -d -p 2222:22 tutum/debian","title":"RUN"},{"location":"chapter02/04servicio/#exec_1","text":"Consultar la configuraci\u00f3n que qued\u00f3 levantada para el acceso ssh: $ docker container logs 3a49c40eee76 => Setting a random password to the root user => Done! ======================================================================== You can now connect to this Debian container via SSH using: ssh -p <port> root@<host> and enter the root password 'vVuzz8JcvafD' when prompted Please remember to change the above password as soon as possible! ========================================================================","title":"EXEC"},{"location":"chapter02/04servicio/#utilizar-servicio","text":"$ ssh -p 2222 root@127.0.0.1","title":"Utilizar servicio"},{"location":"chapter02/04servicio/#stop-rm","text":"docker container rm permite borrar los contenedores apagados ( stop ) \u00fanicamente. $ docker container rm Error response from daemon: You cannot remove a running container 3a49c40eee762a5887ba2d11dd801c98a7b8c22031ca049f1022f2f2ab9ca745. Stop the container before attempting removal or force remove $ docker container stop 3a49c40eee76 3a49c40eee76 $ docker container rm 3a49c40eee76 3a49c40eee76","title":"STOP -&gt; RM"},{"location":"chapter02/04servicio/#prune","text":"docker container prune borra todos los contenedores que est\u00e1n detenidos.","title":"PRUNE"},{"location":"chapter02/04servicio/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter02/04servicio/#1","text":"Borrar todos los container apagados utilizando los comandos: docker container ps -a docker container rm <CONTAINER-ID>","title":"1."},{"location":"chapter02/04servicio/#2","text":"Volver a ejecutar el container ( Simple-webserver )como se muestra a principio esta secci\u00f3n verificando que est\u00e9 activo y tratar de borrarlo con los comandos, verificando las diferencias entre ellos: docker container rm <CONTAINER-ID> docker container rm -f <CONTAINER-ID>","title":"2."},{"location":"chapter02/04servicio/#3","text":"Volver a ejecutar el container ( Simple-webserver ) pero esta vez sin el par\u00e1metro -d dejando el servicio en primer plano. Desde otra consola hacer conexiones con curl http://localhost:8082 Salir con Ctrl-C y verificar qu\u00e9 sucede con el contenedor utilizando el comando docker container ls","title":"3."},{"location":"chapter02/04servicio/#referencias","text":"docker container docker run Im\u00e1gen andygrunwald/simple-webserver Im\u00e1gen tutum/debian","title":"Referencias:"},{"location":"chapter02/","text":"Primeros pasos Estos ejemplos de primeros pasos pretenden mostrar r\u00e1pidamente acciones b\u00e1sicas que se suelen realizar con docker y, a la vez, dar una primer impresi\u00f3n de su potencia para la ejecuci\u00f3n de aplicaciones. Puede verificar las opciones disponibles con el comando docker sin ning\u00fan par\u00e1metro ni argumento: Usage: docker COMMAND Management Commands: config Manage Docker configs container Manage containers image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumes El comando container es la opci\u00f3n por defecto del comando docker, por lo que generalmente no se escribe, utilizando directamente los sub-comandos. Ejercicios 1. Revise con el comando ps los procesos docker que est\u00e1n corriendo en su equipo. 2. Revise los paquetes que est\u00e1n instalados vinculados a docker en su sistema 3. Liste el status y reinicie el daemon correspondiente a los servicios de Docker Engine. 4. Localice con el comando whereis d\u00f3nde se encuentra el ejecutable docker","title":"Primeros pasos"},{"location":"chapter02/#primeros-pasos","text":"Estos ejemplos de primeros pasos pretenden mostrar r\u00e1pidamente acciones b\u00e1sicas que se suelen realizar con docker y, a la vez, dar una primer impresi\u00f3n de su potencia para la ejecuci\u00f3n de aplicaciones. Puede verificar las opciones disponibles con el comando docker sin ning\u00fan par\u00e1metro ni argumento: Usage: docker COMMAND Management Commands: config Manage Docker configs container Manage containers image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumes El comando container es la opci\u00f3n por defecto del comando docker, por lo que generalmente no se escribe, utilizando directamente los sub-comandos.","title":"Primeros pasos"},{"location":"chapter02/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter02/#1","text":"Revise con el comando ps los procesos docker que est\u00e1n corriendo en su equipo.","title":"1."},{"location":"chapter02/#2","text":"Revise los paquetes que est\u00e1n instalados vinculados a docker en su sistema","title":"2."},{"location":"chapter02/#3","text":"Liste el status y reinicie el daemon correspondiente a los servicios de Docker Engine.","title":"3."},{"location":"chapter02/#4","text":"Localice con el comando whereis d\u00f3nde se encuentra el ejecutable docker","title":"4."},{"location":"chapter03/01imagenes/","text":"Gesti\u00f3n de im\u00e1genes SEARCH El Registry de im\u00e1genes p\u00fablico Docker Hub se puede buscar mediante web o con el comando search : docker search ubuntu | head desplegar\u00e1 la totalidad de las im\u00e1genes que posean ubuntu en su nombre o descripci\u00f3n. En Docker Hub existen dos tipos de im\u00e1genes: im\u00e1genes oficiales , que son mantenidas por Docker y reciben aportes de la comunidad. Est\u00e1n pensadas para repositorio de distribuciones, mejores pr\u00e1cticas, seguridad. Se identifican por su nombre sin barra: ubuntu y por tener el atributo OFFICIAL docker search --filter is-official=true ubuntu im\u00e1genes de usuarios , son creadas, mantenidas y compartidas por usuarios. Se identifican por anteponer el nombre del usuario: username/imagen docker search tutum Listar tags Podemos consultar por el tag de la imagen, directamente invocando al api del registry que nos devolver\u00e1 un JSON que podemos filtrar con el comando jq : curl -s -S 'https://registry.hub.docker.com/v2/repositories/library/ubuntu/tags/' | jq '.\"results\"[][\"name\"]' |sort PULL La forma de descargar una imagen para incorporarla al repositorio local es con el comando pull : docker pull ubuntu:bionic run adem\u00e1s de ejecutar una imagen docker, tambi\u00e9n la descarga y la deja en el repositorio si no est\u00e1 descargada. TAG El comando tag permite poner el nombre que queremos a una imagen en el formato repositorio:etiqueta docker tag ubuntu:bionic pruebas:locales Que generar\u00e1 una nueva entrada en el repositorio local con el nombre que deseamos: REPOSITORY TAG IMAGE ID CREATED SIZE pruebas locales 452a96d81c30 5 weeks ago 79.6MB ubuntu bionic 452a96d81c30 5 weeks ago 79.6MB En el repositorio local podemos hacer b\u00fasqueda de im\u00e1genes con diferentes filtros: docker images ubuntu:* Y el comando docker images posee la opci\u00f3n --filter que permite buscar im\u00e1genes por distintas caracter\u00edsticas -f, --filter valor Filtrado de la salida basado en condiciones - dangling=(true|false) - label=<key> o label=<key>=<value> - before=(<image-name>[:tag]|<image-id>|<image@digest>) - since=(<image-name>[:tag]|<image-id>|<image@digest>) - reference=(pattern of an image reference) Buscar im\u00e1genes que no est\u00e1n asociadas ( unused ) a un contenedor ejecut\u00e1ndose: docker images --filter \"running=false\" Buscar im\u00e1genes que no est\u00e1n asociadas a una nueva imagen (nueva capa): docker images --filter \"dangling=true\" INSPECT Permite obtener informaci\u00f3n detallada de una imagen que se encuentra descargada. Conocer el CMD que corre al arrancar: $ docker image inspect hello-world \"Cmd\": [ \"/hello\" ], Ver los puertos que est\u00e1n EXPOSE: $ docker image inspect andygrunwald/simple-webserver:latest \"ExposedPorts\": { \"8082/tcp\": {} }, RMI Para borrar im\u00e1genes del repositorio local se utiliza el comando rmi : docker images rmi pruebas:locales Para borrar todas las im\u00e1genes que no est\u00e1n en uso actualmente ( unused y dangling ): docker images prune Ejercicios 1. Descargar la imagen de ubuntu correspondiente a xenial Referencias: Docker Hub Official images on Docker Hub docker image inspect docker image filtering Imagen ubuntu","title":"Gesti\u00f3n de im\u00e1genes"},{"location":"chapter03/01imagenes/#gestion-de-imagenes","text":"","title":"Gesti\u00f3n de im\u00e1genes"},{"location":"chapter03/01imagenes/#search","text":"El Registry de im\u00e1genes p\u00fablico Docker Hub se puede buscar mediante web o con el comando search : docker search ubuntu | head desplegar\u00e1 la totalidad de las im\u00e1genes que posean ubuntu en su nombre o descripci\u00f3n. En Docker Hub existen dos tipos de im\u00e1genes: im\u00e1genes oficiales , que son mantenidas por Docker y reciben aportes de la comunidad. Est\u00e1n pensadas para repositorio de distribuciones, mejores pr\u00e1cticas, seguridad. Se identifican por su nombre sin barra: ubuntu y por tener el atributo OFFICIAL docker search --filter is-official=true ubuntu im\u00e1genes de usuarios , son creadas, mantenidas y compartidas por usuarios. Se identifican por anteponer el nombre del usuario: username/imagen docker search tutum","title":"SEARCH"},{"location":"chapter03/01imagenes/#listar-tags","text":"Podemos consultar por el tag de la imagen, directamente invocando al api del registry que nos devolver\u00e1 un JSON que podemos filtrar con el comando jq : curl -s -S 'https://registry.hub.docker.com/v2/repositories/library/ubuntu/tags/' | jq '.\"results\"[][\"name\"]' |sort","title":"Listar tags"},{"location":"chapter03/01imagenes/#pull","text":"La forma de descargar una imagen para incorporarla al repositorio local es con el comando pull : docker pull ubuntu:bionic run adem\u00e1s de ejecutar una imagen docker, tambi\u00e9n la descarga y la deja en el repositorio si no est\u00e1 descargada.","title":"PULL"},{"location":"chapter03/01imagenes/#tag","text":"El comando tag permite poner el nombre que queremos a una imagen en el formato repositorio:etiqueta docker tag ubuntu:bionic pruebas:locales Que generar\u00e1 una nueva entrada en el repositorio local con el nombre que deseamos: REPOSITORY TAG IMAGE ID CREATED SIZE pruebas locales 452a96d81c30 5 weeks ago 79.6MB ubuntu bionic 452a96d81c30 5 weeks ago 79.6MB En el repositorio local podemos hacer b\u00fasqueda de im\u00e1genes con diferentes filtros: docker images ubuntu:* Y el comando docker images posee la opci\u00f3n --filter que permite buscar im\u00e1genes por distintas caracter\u00edsticas -f, --filter valor Filtrado de la salida basado en condiciones - dangling=(true|false) - label=<key> o label=<key>=<value> - before=(<image-name>[:tag]|<image-id>|<image@digest>) - since=(<image-name>[:tag]|<image-id>|<image@digest>) - reference=(pattern of an image reference) Buscar im\u00e1genes que no est\u00e1n asociadas ( unused ) a un contenedor ejecut\u00e1ndose: docker images --filter \"running=false\" Buscar im\u00e1genes que no est\u00e1n asociadas a una nueva imagen (nueva capa): docker images --filter \"dangling=true\"","title":"TAG"},{"location":"chapter03/01imagenes/#inspect","text":"Permite obtener informaci\u00f3n detallada de una imagen que se encuentra descargada. Conocer el CMD que corre al arrancar: $ docker image inspect hello-world \"Cmd\": [ \"/hello\" ], Ver los puertos que est\u00e1n EXPOSE: $ docker image inspect andygrunwald/simple-webserver:latest \"ExposedPorts\": { \"8082/tcp\": {} },","title":"INSPECT"},{"location":"chapter03/01imagenes/#rmi","text":"Para borrar im\u00e1genes del repositorio local se utiliza el comando rmi : docker images rmi pruebas:locales Para borrar todas las im\u00e1genes que no est\u00e1n en uso actualmente ( unused y dangling ): docker images prune","title":"RMI"},{"location":"chapter03/01imagenes/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter03/01imagenes/#1","text":"Descargar la imagen de ubuntu correspondiente a xenial","title":"1."},{"location":"chapter03/01imagenes/#referencias","text":"Docker Hub Official images on Docker Hub docker image inspect docker image filtering Imagen ubuntu","title":"Referencias:"},{"location":"chapter03/02crear/","text":"Crear im\u00e1genes propias Existen dos m\u00e9todos para crear im\u00e1genes propias: Hacer cambios en un contenedor y exportarlo como imagen al repositorio local: Crear a partir de un contenedor Hacer un build a partir de un archivo Dockerfile : Crear usando Dockerfile","title":"Crear im\u00e1genes propias"},{"location":"chapter03/02crear/#crear-imagenes-propias","text":"Existen dos m\u00e9todos para crear im\u00e1genes propias: Hacer cambios en un contenedor y exportarlo como imagen al repositorio local: Crear a partir de un contenedor Hacer un build a partir de un archivo Dockerfile : Crear usando Dockerfile","title":"Crear im\u00e1genes propias"},{"location":"chapter03/03crear-contenedor/","text":"Crear a partir de un contenedor - COMMIT Correr una contenedor basado en la imagen debian e ingresar al shell para hacer cambios: docker container run -ti debian bash Ejecutar estos comandos para instalar figlet y salir apt-get update apt-get install -y figlet figlet 'hello docker' exit El container est\u00e1 detenido y a partir de \u00e9l se puede crear una imagen, que se guarda en el repositorio local, con el comando container commit docker container ls -a docker container commit <CONTAINER-ID> docker image ls Le colocamos el nombre a la imagen generada con el comando image tag pues no lo hicimos junto con el container commit docker image tag <IMAGE-ID> configlet docker image ls Ahora que disponemos de una imagen basada en debian que tiene el comando figlet instalado la podemos utilizar: docker container run configlet figlet hola Ejercicios 1. Utilizando la imagen ruby:latest crear una imagen llamada ruby-hello que contenga un ejecutable hello.rb con el siguiente c\u00f3digo: TIP : probar c\u00f3digo en l\u00ednea de comando antes de crear la imagen. print \"Hello Ruby!\\n\" print \"Goodbye Ruby!\\n\"` De forma de poder invocarlo: docker run --rm ruby-hello ./hello.rb Referencias: docker commit","title":"Crear a partir de un contenedor - COMMIT"},{"location":"chapter03/03crear-contenedor/#crear-a-partir-de-un-contenedor-commit","text":"Correr una contenedor basado en la imagen debian e ingresar al shell para hacer cambios: docker container run -ti debian bash Ejecutar estos comandos para instalar figlet y salir apt-get update apt-get install -y figlet figlet 'hello docker' exit El container est\u00e1 detenido y a partir de \u00e9l se puede crear una imagen, que se guarda en el repositorio local, con el comando container commit docker container ls -a docker container commit <CONTAINER-ID> docker image ls Le colocamos el nombre a la imagen generada con el comando image tag pues no lo hicimos junto con el container commit docker image tag <IMAGE-ID> configlet docker image ls Ahora que disponemos de una imagen basada en debian que tiene el comando figlet instalado la podemos utilizar: docker container run configlet figlet hola","title":"Crear a partir de un contenedor - COMMIT"},{"location":"chapter03/03crear-contenedor/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter03/03crear-contenedor/#1","text":"Utilizando la imagen ruby:latest crear una imagen llamada ruby-hello que contenga un ejecutable hello.rb con el siguiente c\u00f3digo: TIP : probar c\u00f3digo en l\u00ednea de comando antes de crear la imagen. print \"Hello Ruby!\\n\" print \"Goodbye Ruby!\\n\"` De forma de poder invocarlo: docker run --rm ruby-hello ./hello.rb","title":"1."},{"location":"chapter03/03crear-contenedor/#referencias","text":"docker commit","title":"Referencias:"},{"location":"chapter03/04crear-dockerfile/","text":"Crear usando Dockerfile - BUILD Give a sysadmin an image and their app will be up-to-date for a day, give a sysadmin a Dockerfile and their app will always be up-to-date Dockerfile es un archivo de texto que contiene un conjunto de instrucciones o comandos para la creaci\u00f3n de una imagen docker. Llamando a la funci\u00f3n docker build se leen las instrucciones del Dockerfile y se construye una imagen que se guardar\u00e1 en el repositorio local. Uso de Dockerfile Para la construcci\u00f3n de una imagen se utiliza el comando docker build ${CONTEXT} . El ${CONTEXT} son todos los archivos que necesita el Dockerfile para construir la imagen; puede ser una carpeta de nuestra propia m\u00e1quina o una URL de un repositorio git. El proceso de build lo ejecuta Docker Daemon y no el utilitario docker. Todo el ${CONTEXT} es enviado a docker daemon, por lo que no es recomendable utilizar un path con demasiados archivos, ya que todos ser\u00e1n enviados. El archivo Dockerfile debe estar localizado en el ra\u00edz del ${CONTEXT} Tambi\u00e9n se puede utilizar un archivo .dockerignore para especificar los archivos y carpetas que deben ser excluidos del proceso de construcci\u00f3n de la imagen y que no ser\u00e1n enviados al docker daemon, lo que mejorar\u00e1 la performance del proceso de build . BUILD El Dockerfile siempre parte de una imagen creada, mediante la instrucci\u00f3n FROM . FROM node:latest Con esta sola instrucci\u00f3n ya podemos crear una imagen, utilizando como ${CONTEXT} el directorio actual: $ docker build . Sending build context to Docker daemon 2.048 kB Step 1 : FROM node:latest ---> 36dc1bb7a52b Successfully built 36dc1bb7a52b Es posible indicar la ubicaci\u00f3n del Dockerfile con el argumento -f : docker build -f image/Dockerfile image/ Tambi\u00e9n podemos ponerle nombre o etiquetar la imagen a la vez que la construimos utilizando el argumento -t y el nombre que le daremos, en el formato -t ${tag}:${version} : $ docker build -t pilasguru/nodejs . $ docker build -t pilasguru/nodejs:0.0.1 . Una vez construida podemos revisar que la imagen est\u00e9 en nuestro repositorio $ docker images pilasguru/nodejs REPOSITORY TAG IMAGE ID CREATED SIZE Pilasguru/nodejs 0.0.1 38dc1bb7a34c 2 weeks ago 655.5 MB Pilasguru/nodejs latest 38dc1bb7a34c 2 weeks ago 655.5 MB Estructura del Dockerfile El formato del archivo Dockerfile es: # Comentario INSTRUCCION argument1 argumento2 argumento3 ... La INSTRUCCION no es case-sensitive y por costumbre se suele usar en may\u00fascula. El orden de las instrucciones es importante ya que debe seguir el orden del proceso de construcci\u00f3n de la imagen. Estructura del .dockerignore El archivo .dockerignore tiene un formato como el archivo .gitignore y es un listado por rengl\u00f3n de los archivos o carpetas que son ignorados: # comentario */temp* */*/temp* temp? testing/ .git/ Los asteriscos se utilizan como comodines e incluyen tanto archivos, carpetas y en ese caso las sub-carpetas. Instrucciones del Dockerfile FROM Un Dockerfile v\u00e1lido debe tener este instrucci\u00f3n como su primer instrucci\u00f3n e indica la imagen que se utilizar\u00e1 para construir la nueva imagen. Docker daemon primero verificar\u00e1 si la imagen existe localmente, si no proceder\u00e1 a descargarla de docker hub. Se puede utilizar de tres formas: FROM <imagen> FROM <imagen:tag> FROM <imagen>@<digest> FROM debe ser la primer l\u00ednea no comentada en el Dockerfile. Se puede utilizar m\u00faltiples veces en el mismo Dockerfile. Tanto el tag como digest son opcionales y permiten tratar de obtener la imagen exacta, pero de no estar disponible se usar\u00e1 la \u00faltima ( latest ) MAINTAINER Permite indicar el autor de la imagen y se utiliza asi: MAINTAINER <nombre> RUN Permite indicar comandos que ser\u00e1n ejecutados en una nueva capa sobre la imagen (del FROM) en el proceso de construcci\u00f3n y ese resultado ser\u00e1 guardado para pasarlo, opcionalmente, a un siguiente RUN que volver\u00e1 a crear una nueva capa. RUN tiene dos formatos: shell RUN <comando> es el formato shell . El comando se ejecutar\u00e1 en un shell que por defecto es /bin/sh -c de Linux o cmd /S /C de Windows. exec RUN [\u201cejecutable\u201d, \u201cargumento1\u201d, \u201cargumento2\u201d, \u201cargumento3\u201d \u2026] El formato exec no invoca a un shell y el parser se realiza mediante un array json, por lo que requiere doble comillas (no comillas simples). Un ejemplo de Dockerfile hasta ahora, quedar\u00eda construido de la siguiente forma: # Ejemplo # ---------- FROM node:latest MAINTAINER pilasguru RUN /bin/bash -c 'echo \"*** hello Dockerfile!! ***\"' RUN [\"npm\", \"--version\"] Creando una imagen con este ejemplo, tendremos la siguiente salida: \u279c docker build -t pilasguru/nodejs:0.0.3 . \u2026 Step 3 : RUN /bin/sh -c 'echo \"*** hello Dockerfile!! ***\"' ---> Running in 6ebfa85f7683 *** hello Dockerfile!! *** \u2026 Step 4 : RUN npm --version ---> Running in fc9dab7cf8c2 3.10.10 \u2026 LABEL Esta instrucci\u00f3n incluye metadatos a la imagen en el formato de pares llave-valor: LABEL <llave>=<valor> <llave>=<valor> <llae>=<valor> ... Y se pueden utilizar m\u00faltiples l\u00edneas de LABEL: LABEL \"com.ejemplo.imagen\"=\"Node JS imagen LABEL ejemplo\" LABEL version=\"0.0.4\" LABEL descripcion=\"valores pueden ser \\ separados en varias l\u00edneas\" Y por supuesto que se pueden indicar varios pares de llaves=valor en la misma instrucci\u00f3n LABEL. Veamos la construcci\u00f3n de una imagen y sus metadatos: $ docker build -t pilasguru/nodejs:0.0.3 . --no-cache=true $ docker inspect pilasguru/nodejs:0.0.3 \u2026 \"Labels\": { \"com.ejemplo.imagen\": \"Node JS image LABEL ejemplo\", \"descripcion\": \"valores pueden ser Separados en varias l\u00edneas\", \"version\": \"0.0.4\" } \u2026 EXPOSE Esta instrucci\u00f3n informa a Docker que el contenedor escuchar\u00e1 en un determinado puerto cuando est\u00e9 corriendo. EXPOSE <port> [<port>...] No significa que el puerto ser\u00e1 accesible desde el host. Para construir la red, se debe utilizar el argumento -p que publicar\u00e1 el punto al correr docker. ENV Permite configurar variables de entorno en el contenedor cuando est\u00e9 corriendo. ENV MYSQL_PASS passw0rd ENV SRCFOLDER ./src/app Se pueden consultar las declaraciones de ENV con el comando inspect : $ docker inspect pilasguru/nodejs:0.0.3 | \\ jq .[].ContainerConfig.Env [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"NODE_VERSION=11.11.0\", \"YARN_VERSION=1.13.0\" ] $ docker inspect -f \"{{ .Config.Env }}\" pilasguru/nodejs:0.0.3 ADD La instrucci\u00f3n ADD copia nuevos archivos, directorios o archivos remotos (desde una URL) desde un <src> y los agrega a la imagen en el lugar indicado en <dest> . Ejemplos: ADD . /app/ ADD [ \"dir con espacios/\" \"/app/\" ] En los dos ejemplos de arriba se copian los archivos de los directorios indicados en la carpeta /app/ dentro de la imagen. Si el <dest> no finaliza barra al final, se considera un archivo y en \u00e9l se escribir\u00e1 el contenido de <src> . Si <dest> no existe, ser\u00e1 creado. Se permite el uso de asteriscos en <src> como ser arch* o readm?.txt . Si el origen <src> es un compactado (tar, gzip, bzip2 o xz) la ejecuci\u00f3n de ADD lo descompactar\u00e1 dentro de <dest> . COPY COPY es muy similar a ADD: hace lo mismo y tiene el mismo formato. La diferencia es que COPY no acepta URLs como <src> y en caso de ser un archivo compactado, no lo descompactar\u00e1 al copiarlo dentro de la imagen. ENTRYPOINT Este comando permite especificar un comando que ser\u00e1 siempre ejecutado cada vez que se inicie el container. ENTRYPOINT [\"/bin/echo\", \"Hola pilasguru\"] $ docker build -t pilasguru/nodejs:0.0.3 . --no-cache=true $ docker run -it --name minodejs pilasguru/nodejs:0.0.3 Hola pilasguru Tenga en cuenta que solamente un ENTRYPOINT es permitido en el Dockerfile. CMD Al igual que ENTRYPOINT permite especificar comandos a ejecutar cuando se inicie el contenedor y tambi\u00e9n, solamente un CMD es permitido en el Dockerfile. La caracter\u00edstica de CMD es que ser\u00e1 omitido en caso de que el contenedor se inicie especificando otro comando. Si un Dockerfile especifica: ENTRYPOINT [\"/bin/echo\", \"Hola ENTRYPOINT\"] CMD [\"/bin/echo\" \"Hola CMD!!\"] Y constru\u00edmos la imagen: $ docker build -t pilasguru/nodejs:0.0.3 . --no-cache=true Y ejecutamos: $ docker run -it --name minodejs pilasguru/nodejs:0.0.3 Hola ENTRYPOINT Hola CMD!! Ahora si creamos un segundo comando, pero indicando un comando: $ docker run -it --name minodejs pilasguru/nodejs:0.0.3 echo \"Que onda!\" Hola ENTRYPOINT Que onda! VOLUME La instrucci\u00f3n VOLUME creara un punto de montado con el nombre especificado y tendr\u00e1 el filesystem externo al contenedor VOLUME /var/log USER La instrucci\u00f3n USER seguido del nombre o UID indica bajo que usuario correr\u00e1n las instrucciones RUN, CMD o ENTRYPOINT. WORKDIR WORKDIR permite indicar el directorio en el cual los comandos de RUN, CMD, ENTRYPOINT, COPY y ADD ser\u00e1n ejecutados. Si el directorio WORKDIR no existe, ser\u00e1 creado. WORKDIR puede ser visto como el home del contenedor Ejemplos de Dockerfile Las lineas comentadas son auto-explicativas. Nodejs app Dockerfile: FROM node:argon # Create app directory RUN mkdir -p /usr/src/app WORKDIR /usr/src/app # Install app dependencies COPY package.json /usr/src/app/ RUN npm install # Bundle app source COPY . /usr/src/app EXPOSE 8080 CMD [ \"npm\", \"start\" ] Nginx Dockerfile: FROM debian:jessie MAINTAINER NGINX Docker Maintainers \"docker-maint@nginx.com\" ENV NGINX_VERSION 1.11.7-1~jessie RUN apt-key adv --keyserver hkp://pgp.mit.edu:80 --recv-keys 573BFD6B3D8FBC641079A6ABABF5BD827BD9BF62 \\ && echo \"deb http://nginx.org/packages/mainline/debian/ jessie nginx\" >> /etc/apt/sources.list \\ && apt-get update \\ && apt-get install --no-install-recommends --no-install-suggests -y \\ ca-certificates \\ nginx=${NGINX_VERSION} \\ nginx-module-xslt \\ nginx-module-geoip \\ nginx-module-image-filter \\ nginx-module-perl \\ nginx-module-njs \\ gettext-base \\ && rm -rf /var/lib/apt/lists/* # forward request and error logs to docker log collector RUN ln -sf /dev/stdout /var/log/nginx/access.log \\ && ln -sf /dev/stderr /var/log/nginx/error.log EXPOSE 80 443 CMD [ \"nginx\", \"-g\", \"daemon off;\" ] Ejercicios 1. Crear un archivo con el nombre index.js con el siguiente contenido: var os = require(\"os\"); var hostname = os.hostname(); console.log(\"Un saludo desde \" + hostname); Crear un archivo con el nombre Dockerfile con el siguiente contenido. FROM alpine RUN apk update && apk add nodejs COPY . /app WORKDIR /app CMD [\"node\",\"index.js\"] Con el comando build construimos la imagen que seguir\u00e1 el script configurado en el Dockerfile que se busca en el directorio actual con el \u00faltimo punto docker image build -t hello:v0.1 . Sending build context to Docker daemon 3.072kB Step 1/5 : FROM alpine ---> 3fd9065eaf02 Step 2/5 : RUN apk update && apk add nodejs ---> Running in 867c66ddedd4 fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/main/x86_64/APKINDEX.tar.gz fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/community/x86_64/APKINDEX.tar.gz v3.7.0-190-g3da66f61a4 [http://dl-cdn.alpinelinux.org/alpine/v3.7/main] v3.7.0-184-ge62f3c3781 [http://dl-cdn.alpinelinux.org/alpine/v3.7/community] OK: 9054 distinct packages available (1/10) Installing ca-certificates (20171114-r0) (2/10) Installing nodejs-npm (8.9.3-r1) (3/10) Installing c-ares (1.13.0-r0) (4/10) Installing libcrypto1.0 (1.0.2o-r0) (5/10) Installing libgcc (6.4.0-r5) (6/10) Installing http-parser (2.7.1-r1) (7/10) Installing libssl1.0 (1.0.2o-r0) (8/10) Installing libstdc++ (6.4.0-r5) (9/10) Installing libuv (1.17.0-r0) (10/10) Installing nodejs (8.9.3-r1) Executing busybox-1.27.2-r7.trigger Executing ca-certificates-20171114-r0.trigger OK: 61 MiB in 21 packages Removing intermediate container 867c66ddedd4 ---> 9f2675ec7ebd Step 3/5 : COPY . /app ---> 3dfd8536a240 Step 4/5 : WORKDIR /app Removing intermediate container c56e9d8a8eb2 ---> 6e9870377075 Step 5/5 : CMD [\"node\",\"index.js\"] ---> Running in 8b80c4c4109d Removing intermediate container 8b80c4c4109d ---> 14ddb4369169 Successfully built 14ddb4369169 Successfully tagged hello:v0.1 Con el comando docker image ls se puede ver la imagen reci\u00e9n creada: REPOSITORY TAG IMAGE ID CREATED SIZE hello v0.1 14ddb4369169 About a minute ago 50.2MB docker container run --rm hello:v0.1 2. Utilizando la imagen ruby:2.1-onbuild crear una imagen para revisar la existencia de gemas ejecutando: docker run --rm checker-image ruby checker.rb <gema> Las im\u00e1genes onbuild fueron creadas con la directiva ONBUILD en su Dockerfile . Esta directiva permite indicar comandos para cu\u00e1ndo la imagen sea utilizada para un build , en el caso de ruby el comando es bundle install . Son utilizadas a los efectos de testing ( no se recomiendan en producci\u00f3n ). El siguiente c\u00f3digo recibe el nombre de una gema y devuelve si est\u00e1 disponible: # checker.rb require 'curb' gem_name = ARGV[0] raise ArgumentError.new(\"gem name missing\") if gem_name.nil? if Curl.get(\"https://rubygems.org/gems/#{gem_name}\").status == '200 OK' $stdout.puts 'Name available.' else $stdout.puts 'Name not available.' end Referencias: Best practices for writing Dockerfiles Dockerfile ONBUILD","title":"Crear usando Dockerfile - BUILD"},{"location":"chapter03/04crear-dockerfile/#crear-usando-dockerfile-build","text":"Give a sysadmin an image and their app will be up-to-date for a day, give a sysadmin a Dockerfile and their app will always be up-to-date Dockerfile es un archivo de texto que contiene un conjunto de instrucciones o comandos para la creaci\u00f3n de una imagen docker. Llamando a la funci\u00f3n docker build se leen las instrucciones del Dockerfile y se construye una imagen que se guardar\u00e1 en el repositorio local.","title":"Crear usando Dockerfile - BUILD"},{"location":"chapter03/04crear-dockerfile/#uso-de-dockerfile","text":"Para la construcci\u00f3n de una imagen se utiliza el comando docker build ${CONTEXT} . El ${CONTEXT} son todos los archivos que necesita el Dockerfile para construir la imagen; puede ser una carpeta de nuestra propia m\u00e1quina o una URL de un repositorio git. El proceso de build lo ejecuta Docker Daemon y no el utilitario docker. Todo el ${CONTEXT} es enviado a docker daemon, por lo que no es recomendable utilizar un path con demasiados archivos, ya que todos ser\u00e1n enviados. El archivo Dockerfile debe estar localizado en el ra\u00edz del ${CONTEXT} Tambi\u00e9n se puede utilizar un archivo .dockerignore para especificar los archivos y carpetas que deben ser excluidos del proceso de construcci\u00f3n de la imagen y que no ser\u00e1n enviados al docker daemon, lo que mejorar\u00e1 la performance del proceso de build .","title":"Uso de Dockerfile"},{"location":"chapter03/04crear-dockerfile/#build","text":"El Dockerfile siempre parte de una imagen creada, mediante la instrucci\u00f3n FROM . FROM node:latest Con esta sola instrucci\u00f3n ya podemos crear una imagen, utilizando como ${CONTEXT} el directorio actual: $ docker build . Sending build context to Docker daemon 2.048 kB Step 1 : FROM node:latest ---> 36dc1bb7a52b Successfully built 36dc1bb7a52b Es posible indicar la ubicaci\u00f3n del Dockerfile con el argumento -f : docker build -f image/Dockerfile image/ Tambi\u00e9n podemos ponerle nombre o etiquetar la imagen a la vez que la construimos utilizando el argumento -t y el nombre que le daremos, en el formato -t ${tag}:${version} : $ docker build -t pilasguru/nodejs . $ docker build -t pilasguru/nodejs:0.0.1 . Una vez construida podemos revisar que la imagen est\u00e9 en nuestro repositorio $ docker images pilasguru/nodejs REPOSITORY TAG IMAGE ID CREATED SIZE Pilasguru/nodejs 0.0.1 38dc1bb7a34c 2 weeks ago 655.5 MB Pilasguru/nodejs latest 38dc1bb7a34c 2 weeks ago 655.5 MB","title":"BUILD"},{"location":"chapter03/04crear-dockerfile/#estructura-del-dockerfile","text":"El formato del archivo Dockerfile es: # Comentario INSTRUCCION argument1 argumento2 argumento3 ... La INSTRUCCION no es case-sensitive y por costumbre se suele usar en may\u00fascula. El orden de las instrucciones es importante ya que debe seguir el orden del proceso de construcci\u00f3n de la imagen.","title":"Estructura del Dockerfile"},{"location":"chapter03/04crear-dockerfile/#estructura-del-dockerignore","text":"El archivo .dockerignore tiene un formato como el archivo .gitignore y es un listado por rengl\u00f3n de los archivos o carpetas que son ignorados: # comentario */temp* */*/temp* temp? testing/ .git/ Los asteriscos se utilizan como comodines e incluyen tanto archivos, carpetas y en ese caso las sub-carpetas.","title":"Estructura del .dockerignore"},{"location":"chapter03/04crear-dockerfile/#instrucciones-del-dockerfile","text":"","title":"Instrucciones del Dockerfile"},{"location":"chapter03/04crear-dockerfile/#from","text":"Un Dockerfile v\u00e1lido debe tener este instrucci\u00f3n como su primer instrucci\u00f3n e indica la imagen que se utilizar\u00e1 para construir la nueva imagen. Docker daemon primero verificar\u00e1 si la imagen existe localmente, si no proceder\u00e1 a descargarla de docker hub. Se puede utilizar de tres formas: FROM <imagen> FROM <imagen:tag> FROM <imagen>@<digest> FROM debe ser la primer l\u00ednea no comentada en el Dockerfile. Se puede utilizar m\u00faltiples veces en el mismo Dockerfile. Tanto el tag como digest son opcionales y permiten tratar de obtener la imagen exacta, pero de no estar disponible se usar\u00e1 la \u00faltima ( latest )","title":"FROM"},{"location":"chapter03/04crear-dockerfile/#maintainer","text":"Permite indicar el autor de la imagen y se utiliza asi: MAINTAINER <nombre>","title":"MAINTAINER"},{"location":"chapter03/04crear-dockerfile/#run","text":"Permite indicar comandos que ser\u00e1n ejecutados en una nueva capa sobre la imagen (del FROM) en el proceso de construcci\u00f3n y ese resultado ser\u00e1 guardado para pasarlo, opcionalmente, a un siguiente RUN que volver\u00e1 a crear una nueva capa. RUN tiene dos formatos: shell RUN <comando> es el formato shell . El comando se ejecutar\u00e1 en un shell que por defecto es /bin/sh -c de Linux o cmd /S /C de Windows. exec RUN [\u201cejecutable\u201d, \u201cargumento1\u201d, \u201cargumento2\u201d, \u201cargumento3\u201d \u2026] El formato exec no invoca a un shell y el parser se realiza mediante un array json, por lo que requiere doble comillas (no comillas simples). Un ejemplo de Dockerfile hasta ahora, quedar\u00eda construido de la siguiente forma: # Ejemplo # ---------- FROM node:latest MAINTAINER pilasguru RUN /bin/bash -c 'echo \"*** hello Dockerfile!! ***\"' RUN [\"npm\", \"--version\"] Creando una imagen con este ejemplo, tendremos la siguiente salida: \u279c docker build -t pilasguru/nodejs:0.0.3 . \u2026 Step 3 : RUN /bin/sh -c 'echo \"*** hello Dockerfile!! ***\"' ---> Running in 6ebfa85f7683 *** hello Dockerfile!! *** \u2026 Step 4 : RUN npm --version ---> Running in fc9dab7cf8c2 3.10.10 \u2026","title":"RUN"},{"location":"chapter03/04crear-dockerfile/#label","text":"Esta instrucci\u00f3n incluye metadatos a la imagen en el formato de pares llave-valor: LABEL <llave>=<valor> <llave>=<valor> <llae>=<valor> ... Y se pueden utilizar m\u00faltiples l\u00edneas de LABEL: LABEL \"com.ejemplo.imagen\"=\"Node JS imagen LABEL ejemplo\" LABEL version=\"0.0.4\" LABEL descripcion=\"valores pueden ser \\ separados en varias l\u00edneas\" Y por supuesto que se pueden indicar varios pares de llaves=valor en la misma instrucci\u00f3n LABEL. Veamos la construcci\u00f3n de una imagen y sus metadatos: $ docker build -t pilasguru/nodejs:0.0.3 . --no-cache=true $ docker inspect pilasguru/nodejs:0.0.3 \u2026 \"Labels\": { \"com.ejemplo.imagen\": \"Node JS image LABEL ejemplo\", \"descripcion\": \"valores pueden ser Separados en varias l\u00edneas\", \"version\": \"0.0.4\" } \u2026","title":"LABEL"},{"location":"chapter03/04crear-dockerfile/#expose","text":"Esta instrucci\u00f3n informa a Docker que el contenedor escuchar\u00e1 en un determinado puerto cuando est\u00e9 corriendo. EXPOSE <port> [<port>...] No significa que el puerto ser\u00e1 accesible desde el host. Para construir la red, se debe utilizar el argumento -p que publicar\u00e1 el punto al correr docker.","title":"EXPOSE"},{"location":"chapter03/04crear-dockerfile/#env","text":"Permite configurar variables de entorno en el contenedor cuando est\u00e9 corriendo. ENV MYSQL_PASS passw0rd ENV SRCFOLDER ./src/app Se pueden consultar las declaraciones de ENV con el comando inspect : $ docker inspect pilasguru/nodejs:0.0.3 | \\ jq .[].ContainerConfig.Env [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"NODE_VERSION=11.11.0\", \"YARN_VERSION=1.13.0\" ] $ docker inspect -f \"{{ .Config.Env }}\" pilasguru/nodejs:0.0.3","title":"ENV"},{"location":"chapter03/04crear-dockerfile/#add","text":"La instrucci\u00f3n ADD copia nuevos archivos, directorios o archivos remotos (desde una URL) desde un <src> y los agrega a la imagen en el lugar indicado en <dest> . Ejemplos: ADD . /app/ ADD [ \"dir con espacios/\" \"/app/\" ] En los dos ejemplos de arriba se copian los archivos de los directorios indicados en la carpeta /app/ dentro de la imagen. Si el <dest> no finaliza barra al final, se considera un archivo y en \u00e9l se escribir\u00e1 el contenido de <src> . Si <dest> no existe, ser\u00e1 creado. Se permite el uso de asteriscos en <src> como ser arch* o readm?.txt . Si el origen <src> es un compactado (tar, gzip, bzip2 o xz) la ejecuci\u00f3n de ADD lo descompactar\u00e1 dentro de <dest> .","title":"ADD"},{"location":"chapter03/04crear-dockerfile/#copy","text":"COPY es muy similar a ADD: hace lo mismo y tiene el mismo formato. La diferencia es que COPY no acepta URLs como <src> y en caso de ser un archivo compactado, no lo descompactar\u00e1 al copiarlo dentro de la imagen.","title":"COPY"},{"location":"chapter03/04crear-dockerfile/#entrypoint","text":"Este comando permite especificar un comando que ser\u00e1 siempre ejecutado cada vez que se inicie el container. ENTRYPOINT [\"/bin/echo\", \"Hola pilasguru\"] $ docker build -t pilasguru/nodejs:0.0.3 . --no-cache=true $ docker run -it --name minodejs pilasguru/nodejs:0.0.3 Hola pilasguru Tenga en cuenta que solamente un ENTRYPOINT es permitido en el Dockerfile.","title":"ENTRYPOINT"},{"location":"chapter03/04crear-dockerfile/#cmd","text":"Al igual que ENTRYPOINT permite especificar comandos a ejecutar cuando se inicie el contenedor y tambi\u00e9n, solamente un CMD es permitido en el Dockerfile. La caracter\u00edstica de CMD es que ser\u00e1 omitido en caso de que el contenedor se inicie especificando otro comando. Si un Dockerfile especifica: ENTRYPOINT [\"/bin/echo\", \"Hola ENTRYPOINT\"] CMD [\"/bin/echo\" \"Hola CMD!!\"] Y constru\u00edmos la imagen: $ docker build -t pilasguru/nodejs:0.0.3 . --no-cache=true Y ejecutamos: $ docker run -it --name minodejs pilasguru/nodejs:0.0.3 Hola ENTRYPOINT Hola CMD!! Ahora si creamos un segundo comando, pero indicando un comando: $ docker run -it --name minodejs pilasguru/nodejs:0.0.3 echo \"Que onda!\" Hola ENTRYPOINT Que onda!","title":"CMD"},{"location":"chapter03/04crear-dockerfile/#volume","text":"La instrucci\u00f3n VOLUME creara un punto de montado con el nombre especificado y tendr\u00e1 el filesystem externo al contenedor VOLUME /var/log","title":"VOLUME"},{"location":"chapter03/04crear-dockerfile/#user","text":"La instrucci\u00f3n USER seguido del nombre o UID indica bajo que usuario correr\u00e1n las instrucciones RUN, CMD o ENTRYPOINT.","title":"USER"},{"location":"chapter03/04crear-dockerfile/#workdir","text":"WORKDIR permite indicar el directorio en el cual los comandos de RUN, CMD, ENTRYPOINT, COPY y ADD ser\u00e1n ejecutados. Si el directorio WORKDIR no existe, ser\u00e1 creado. WORKDIR puede ser visto como el home del contenedor","title":"WORKDIR"},{"location":"chapter03/04crear-dockerfile/#ejemplos-de-dockerfile","text":"Las lineas comentadas son auto-explicativas.","title":"Ejemplos de Dockerfile"},{"location":"chapter03/04crear-dockerfile/#nodejs-app-dockerfile","text":"FROM node:argon # Create app directory RUN mkdir -p /usr/src/app WORKDIR /usr/src/app # Install app dependencies COPY package.json /usr/src/app/ RUN npm install # Bundle app source COPY . /usr/src/app EXPOSE 8080 CMD [ \"npm\", \"start\" ]","title":"Nodejs app Dockerfile:"},{"location":"chapter03/04crear-dockerfile/#nginx-dockerfile","text":"FROM debian:jessie MAINTAINER NGINX Docker Maintainers \"docker-maint@nginx.com\" ENV NGINX_VERSION 1.11.7-1~jessie RUN apt-key adv --keyserver hkp://pgp.mit.edu:80 --recv-keys 573BFD6B3D8FBC641079A6ABABF5BD827BD9BF62 \\ && echo \"deb http://nginx.org/packages/mainline/debian/ jessie nginx\" >> /etc/apt/sources.list \\ && apt-get update \\ && apt-get install --no-install-recommends --no-install-suggests -y \\ ca-certificates \\ nginx=${NGINX_VERSION} \\ nginx-module-xslt \\ nginx-module-geoip \\ nginx-module-image-filter \\ nginx-module-perl \\ nginx-module-njs \\ gettext-base \\ && rm -rf /var/lib/apt/lists/* # forward request and error logs to docker log collector RUN ln -sf /dev/stdout /var/log/nginx/access.log \\ && ln -sf /dev/stderr /var/log/nginx/error.log EXPOSE 80 443 CMD [ \"nginx\", \"-g\", \"daemon off;\" ]","title":"Nginx Dockerfile:"},{"location":"chapter03/04crear-dockerfile/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter03/04crear-dockerfile/#1","text":"Crear un archivo con el nombre index.js con el siguiente contenido: var os = require(\"os\"); var hostname = os.hostname(); console.log(\"Un saludo desde \" + hostname); Crear un archivo con el nombre Dockerfile con el siguiente contenido. FROM alpine RUN apk update && apk add nodejs COPY . /app WORKDIR /app CMD [\"node\",\"index.js\"] Con el comando build construimos la imagen que seguir\u00e1 el script configurado en el Dockerfile que se busca en el directorio actual con el \u00faltimo punto docker image build -t hello:v0.1 . Sending build context to Docker daemon 3.072kB Step 1/5 : FROM alpine ---> 3fd9065eaf02 Step 2/5 : RUN apk update && apk add nodejs ---> Running in 867c66ddedd4 fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/main/x86_64/APKINDEX.tar.gz fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/community/x86_64/APKINDEX.tar.gz v3.7.0-190-g3da66f61a4 [http://dl-cdn.alpinelinux.org/alpine/v3.7/main] v3.7.0-184-ge62f3c3781 [http://dl-cdn.alpinelinux.org/alpine/v3.7/community] OK: 9054 distinct packages available (1/10) Installing ca-certificates (20171114-r0) (2/10) Installing nodejs-npm (8.9.3-r1) (3/10) Installing c-ares (1.13.0-r0) (4/10) Installing libcrypto1.0 (1.0.2o-r0) (5/10) Installing libgcc (6.4.0-r5) (6/10) Installing http-parser (2.7.1-r1) (7/10) Installing libssl1.0 (1.0.2o-r0) (8/10) Installing libstdc++ (6.4.0-r5) (9/10) Installing libuv (1.17.0-r0) (10/10) Installing nodejs (8.9.3-r1) Executing busybox-1.27.2-r7.trigger Executing ca-certificates-20171114-r0.trigger OK: 61 MiB in 21 packages Removing intermediate container 867c66ddedd4 ---> 9f2675ec7ebd Step 3/5 : COPY . /app ---> 3dfd8536a240 Step 4/5 : WORKDIR /app Removing intermediate container c56e9d8a8eb2 ---> 6e9870377075 Step 5/5 : CMD [\"node\",\"index.js\"] ---> Running in 8b80c4c4109d Removing intermediate container 8b80c4c4109d ---> 14ddb4369169 Successfully built 14ddb4369169 Successfully tagged hello:v0.1 Con el comando docker image ls se puede ver la imagen reci\u00e9n creada: REPOSITORY TAG IMAGE ID CREATED SIZE hello v0.1 14ddb4369169 About a minute ago 50.2MB docker container run --rm hello:v0.1","title":"1."},{"location":"chapter03/04crear-dockerfile/#2","text":"Utilizando la imagen ruby:2.1-onbuild crear una imagen para revisar la existencia de gemas ejecutando: docker run --rm checker-image ruby checker.rb <gema> Las im\u00e1genes onbuild fueron creadas con la directiva ONBUILD en su Dockerfile . Esta directiva permite indicar comandos para cu\u00e1ndo la imagen sea utilizada para un build , en el caso de ruby el comando es bundle install . Son utilizadas a los efectos de testing ( no se recomiendan en producci\u00f3n ). El siguiente c\u00f3digo recibe el nombre de una gema y devuelve si est\u00e1 disponible: # checker.rb require 'curb' gem_name = ARGV[0] raise ArgumentError.new(\"gem name missing\") if gem_name.nil? if Curl.get(\"https://rubygems.org/gems/#{gem_name}\").status == '200 OK' $stdout.puts 'Name available.' else $stdout.puts 'Name not available.' end","title":"2."},{"location":"chapter03/04crear-dockerfile/#referencias","text":"Best practices for writing Dockerfiles Dockerfile ONBUILD","title":"Referencias:"},{"location":"chapter03/05capas/","text":"Capas de las im\u00e1genes Las im\u00e1genes est\u00e1n formadas en capas. Cada repositorio archiva las capas una \u00fanica vez, aunque pueda ser utilizada por distintas im\u00e1genes. De la misma forma, a la hora de transferir una imagen, solo se copiar\u00e1n las capas no disponibles en el repositorio destino. HISTORY Permite consultar la historia de una determinada imagen. docker image history alpine Crear una imagen para consultar su history con este ejemplo auto-explicativo: Dockerfile FROM alpine RUN apk update && apk add nodejs COPY . /app WORKDIR /app CMD [\"node\",\"index.js\"] Comandos: echo \"console.log(\\\"version imagen v0.2\\\");\" >> index.js docker image build -t hello:v0.2 . docker image ls docker container run --rm hello:v0.2 docker image history hello:v0.2 INSPECT Consulta todos los datos de una imagen. Bajo RootFS.Layers se listan los identificadores \u00fanicos (SHA256) de cada capa, que permite el archivo en los repositorios ( Registry ) docker image inspect alpine docker image inspect --format \"{{ json .RootFS.Layers }}\" alpine docker image inspect --format \"{{ json .RootFS.Layers }}\" hello:v0.2 Referencias: docker image history docker image inspect","title":"Capas de las im\u00e1genes"},{"location":"chapter03/05capas/#capas-de-las-imagenes","text":"Las im\u00e1genes est\u00e1n formadas en capas. Cada repositorio archiva las capas una \u00fanica vez, aunque pueda ser utilizada por distintas im\u00e1genes. De la misma forma, a la hora de transferir una imagen, solo se copiar\u00e1n las capas no disponibles en el repositorio destino.","title":"Capas de las im\u00e1genes"},{"location":"chapter03/05capas/#history","text":"Permite consultar la historia de una determinada imagen. docker image history alpine Crear una imagen para consultar su history con este ejemplo auto-explicativo: Dockerfile FROM alpine RUN apk update && apk add nodejs COPY . /app WORKDIR /app CMD [\"node\",\"index.js\"] Comandos: echo \"console.log(\\\"version imagen v0.2\\\");\" >> index.js docker image build -t hello:v0.2 . docker image ls docker container run --rm hello:v0.2 docker image history hello:v0.2","title":"HISTORY"},{"location":"chapter03/05capas/#inspect","text":"Consulta todos los datos de una imagen. Bajo RootFS.Layers se listan los identificadores \u00fanicos (SHA256) de cada capa, que permite el archivo en los repositorios ( Registry ) docker image inspect alpine docker image inspect --format \"{{ json .RootFS.Layers }}\" alpine docker image inspect --format \"{{ json .RootFS.Layers }}\" hello:v0.2","title":"INSPECT"},{"location":"chapter03/05capas/#referencias","text":"docker image history docker image inspect","title":"Referencias:"},{"location":"chapter03/06subir/","text":"Registry Registry es una aplicaci\u00f3n servidor presenta un repositorio de im\u00e1genes. Se distribuye en el contenedor registry . Cuando se desea disponer de una imagen compartida se utiliza Registry de donde los destinos de ejecuci\u00f3n (usuarios, nodos del cluster, etc.) puedan obtenerla. Configurar Registry Por defecto Docker utiliza docker.io como Registry p\u00fablico. Para utilizar otro existen diferentes mecanismos: PULL de registry propio Para hacer pull de un sever propio: docker pull localhost:5000/registry-demo Si los repositorios son privados: docker login https://<YOUR-DOMAIN>:8080 docker pull <YOUR-DOMAIN>:8080/test-image Si la configuraci\u00f3n se desea permanente: Variable de ambiente DOCKER_OPTS DOCKER_OPTS=\"--insecure-registry <YOUR-DOMAIN>:8080\" Archivo /etc/default/docker PUSH Para compartir im\u00e1genes en Docker Hub se debe poseer una cuenta y primeramente estar logrado: $ docker login Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. Username: pilasguru Password: Login Succeeded Una vez ingresado, la im\u00e1genes debe tener un nombre (tag) formado por usuario/nombre-imagen , en mi caso: docker tag localtest:latest pilasguru/test Reci\u00e9n con este nombre y el comando push se podr\u00e1 subir la imagen a Docker Hub, que tomar\u00e1 el nombre de usuario de la primera parte del nombre de la imagen: $ docker push pilasguru/test The push refers to repository [docker.io/pilasguru/test] cd7100a72410: Preparing latest: digest: sha256:8c03bb07a531c53ad7d0f6e7041b64d81f99c6e493cb39abba56d956b40eacbc size: 528 PUSH a registry propio Se nombra ( tag ) la imagen con el nombre DNS del repositorio: docker tag <imagen> <REGISTRYHOST>/<USERNAME>/<NAME>[:TAG] docker push <REGISTRYHOST>/<USERNAME>/<NAME>[:TAG] En caso de tener un Registry en el puerto no est\u00e1ndar, se debe definir el registry en DOCKER_OPTS como se explica en la secci\u00f3n anterior. Referencias: Docker Registry docker push Pull and push images","title":"Registry"},{"location":"chapter03/06subir/#registry","text":"Registry es una aplicaci\u00f3n servidor presenta un repositorio de im\u00e1genes. Se distribuye en el contenedor registry . Cuando se desea disponer de una imagen compartida se utiliza Registry de donde los destinos de ejecuci\u00f3n (usuarios, nodos del cluster, etc.) puedan obtenerla.","title":"Registry"},{"location":"chapter03/06subir/#configurar-registry","text":"Por defecto Docker utiliza docker.io como Registry p\u00fablico. Para utilizar otro existen diferentes mecanismos:","title":"Configurar Registry"},{"location":"chapter03/06subir/#pull-de-registry-propio","text":"Para hacer pull de un sever propio: docker pull localhost:5000/registry-demo Si los repositorios son privados: docker login https://<YOUR-DOMAIN>:8080 docker pull <YOUR-DOMAIN>:8080/test-image Si la configuraci\u00f3n se desea permanente: Variable de ambiente DOCKER_OPTS DOCKER_OPTS=\"--insecure-registry <YOUR-DOMAIN>:8080\" Archivo /etc/default/docker","title":"PULL de registry propio"},{"location":"chapter03/06subir/#push","text":"Para compartir im\u00e1genes en Docker Hub se debe poseer una cuenta y primeramente estar logrado: $ docker login Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. Username: pilasguru Password: Login Succeeded Una vez ingresado, la im\u00e1genes debe tener un nombre (tag) formado por usuario/nombre-imagen , en mi caso: docker tag localtest:latest pilasguru/test Reci\u00e9n con este nombre y el comando push se podr\u00e1 subir la imagen a Docker Hub, que tomar\u00e1 el nombre de usuario de la primera parte del nombre de la imagen: $ docker push pilasguru/test The push refers to repository [docker.io/pilasguru/test] cd7100a72410: Preparing latest: digest: sha256:8c03bb07a531c53ad7d0f6e7041b64d81f99c6e493cb39abba56d956b40eacbc size: 528","title":"PUSH"},{"location":"chapter03/06subir/#push-a-registry-propio","text":"Se nombra ( tag ) la imagen con el nombre DNS del repositorio: docker tag <imagen> <REGISTRYHOST>/<USERNAME>/<NAME>[:TAG] docker push <REGISTRYHOST>/<USERNAME>/<NAME>[:TAG] En caso de tener un Registry en el puerto no est\u00e1ndar, se debe definir el registry en DOCKER_OPTS como se explica en la secci\u00f3n anterior.","title":"PUSH a registry propio"},{"location":"chapter03/06subir/#referencias","text":"Docker Registry docker push Pull and push images","title":"Referencias:"},{"location":"chapter03/","text":"Im\u00e1genes docker y Registry El sistema de im\u00e1genes de docker permite guardar contenedores docker prontos para utilizar (llamados im\u00e1genes ) en un banco local o remoto. Una imagen es un paquete ejecutable que incluye todo lo necesario para correr la aplicaci\u00f3n (c\u00f3digo, librer\u00edas, entorno y configuraci\u00f3n). El servicio de banco de im\u00e1genes denomina Registry y tiene como objetivo compartir im\u00e1genes entre distintos sistemas, grupos de usuarios o, inclusive, distribuci\u00f3n de software pronto para poner a correr. El Registry puede ser p\u00fablico (an\u00f3nimo) o privado (con validaci\u00f3n). El banco de im\u00e1genes local permite guardar las im\u00e1genes que se descargan de los Registry y tambi\u00e9n las que son creadas localmente en el host donde se ejecuta docker. Utilizando en el nombre de la imagen la URL del Registry es posible subir im\u00e1genes de diferentes repositorios. Referencias: https://docs.docker.com/engine/reference/commandline/images/ https://docs.docker.com/engine/tutorials/dockerimages/","title":"Im\u00e1genes docker y Registry"},{"location":"chapter03/#imagenes-docker-y-registry","text":"El sistema de im\u00e1genes de docker permite guardar contenedores docker prontos para utilizar (llamados im\u00e1genes ) en un banco local o remoto. Una imagen es un paquete ejecutable que incluye todo lo necesario para correr la aplicaci\u00f3n (c\u00f3digo, librer\u00edas, entorno y configuraci\u00f3n). El servicio de banco de im\u00e1genes denomina Registry y tiene como objetivo compartir im\u00e1genes entre distintos sistemas, grupos de usuarios o, inclusive, distribuci\u00f3n de software pronto para poner a correr. El Registry puede ser p\u00fablico (an\u00f3nimo) o privado (con validaci\u00f3n). El banco de im\u00e1genes local permite guardar las im\u00e1genes que se descargan de los Registry y tambi\u00e9n las que son creadas localmente en el host donde se ejecuta docker. Utilizando en el nombre de la imagen la URL del Registry es posible subir im\u00e1genes de diferentes repositorios.","title":"Im\u00e1genes docker y Registry"},{"location":"chapter03/#referencias","text":"https://docs.docker.com/engine/reference/commandline/images/ https://docs.docker.com/engine/tutorials/dockerimages/","title":"Referencias:"},{"location":"chapter04/01bind/","text":"Filesystem del host (bind mount) Bind mount permite usar una carpeta (o archivo) del host que es presentada en el espacio de filesystem del contenedor mediante la t\u00e9cnica de montado bind ( mount -o bind ) de Linux. Bind mount es la forma dar permanencia a los datos de disco del contenedor. El bind mount se especifica en el momento de lanzar el contenedor y permite realizar los procesos de respaldo, migraci\u00f3n, etc. con herramientas fuera de docker. --volume | -v Carpeta Permite apuntar una ruta de carpeta del host y presentarlo dentro del contenedor en un punto de montado. -v path-host:path-container Y se configura al lanzar el contenedor: docker container run --name web-nginx -v /opt/website:/usr/share/nginx/html:ro -d nginx Esto har\u00e1 que la carpeta del host /opt/website quede presentada como la carpeta /usr/share/nginx/html en el contenedor. El atributo :ro har\u00e1 que para el contenedor sea un espacio de solo lectura. Otro contenedor puede ser lanzado con la misma opci\u00f3n de montado ( -v ) para reutilizar los datos generados por el primer contenedor. Archivo Permite presentar una archivo del host dentro del contenedor -v path-to-file:file-in-container docker container run --name web-nginx -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -d nginx Ejercicios: 1. De alguna aplicaci\u00f3n que est\u00e9 desarrollando, ejecutar la imagen docker del servicio que necesita tener levantado, montando el directorio de su aplicaci\u00f3n desde el host. Ejemplos: docker run -it --rm -v $PWD/src:/usr/local/app --workdir /usr/local/app ruby:latest bash # bundle install Referencias: Use bind mounts","title":"Filesystem del host (bind mount)"},{"location":"chapter04/01bind/#filesystem-del-host-bind-mount","text":"Bind mount permite usar una carpeta (o archivo) del host que es presentada en el espacio de filesystem del contenedor mediante la t\u00e9cnica de montado bind ( mount -o bind ) de Linux. Bind mount es la forma dar permanencia a los datos de disco del contenedor. El bind mount se especifica en el momento de lanzar el contenedor y permite realizar los procesos de respaldo, migraci\u00f3n, etc. con herramientas fuera de docker.","title":"Filesystem del host (bind mount)"},{"location":"chapter04/01bind/#-volume-v","text":"","title":"--volume | -v"},{"location":"chapter04/01bind/#carpeta","text":"Permite apuntar una ruta de carpeta del host y presentarlo dentro del contenedor en un punto de montado. -v path-host:path-container Y se configura al lanzar el contenedor: docker container run --name web-nginx -v /opt/website:/usr/share/nginx/html:ro -d nginx Esto har\u00e1 que la carpeta del host /opt/website quede presentada como la carpeta /usr/share/nginx/html en el contenedor. El atributo :ro har\u00e1 que para el contenedor sea un espacio de solo lectura. Otro contenedor puede ser lanzado con la misma opci\u00f3n de montado ( -v ) para reutilizar los datos generados por el primer contenedor.","title":"Carpeta"},{"location":"chapter04/01bind/#archivo","text":"Permite presentar una archivo del host dentro del contenedor -v path-to-file:file-in-container docker container run --name web-nginx -v $PWD/conf/nginx.conf:/etc/nginx/nginx.conf -d nginx","title":"Archivo"},{"location":"chapter04/01bind/#ejercicios","text":"","title":"Ejercicios:"},{"location":"chapter04/01bind/#1","text":"De alguna aplicaci\u00f3n que est\u00e9 desarrollando, ejecutar la imagen docker del servicio que necesita tener levantado, montando el directorio de su aplicaci\u00f3n desde el host. Ejemplos: docker run -it --rm -v $PWD/src:/usr/local/app --workdir /usr/local/app ruby:latest bash # bundle install","title":"1."},{"location":"chapter04/01bind/#referencias","text":"Use bind mounts","title":"Referencias:"},{"location":"chapter04/02volume/","text":"Filesystem del host (volume) Los vol\u00famenes es un recurso administrado por docker y que pueden ser vistos como un disco guardado en el host (pseduo-volumen) para montar en los contenedores. Vol\u00famen Puede ser utilizado por otros contenedores simplemente indicando el nombre del vol\u00famen. La creaci\u00f3n de un volume se puede realizar de dos formas diferentes: al ejecutar docker run creando con nombre docker volume create CREATE Con la opci\u00f3n volume create se puede crear un volumen con un nombre dado, para luego utilizar: docker volume create MisDatos LS Y puede ser visto en el listado de vol\u00famenes disponibles: $ docker volume ls DRIVER VOLUME NAME local MisDatos --volume | -v Esta opci\u00f3n es semejante a bind mount pues se usa con la opci\u00f3n -v pero se indica un nombre en lugar de un path del host. Si no existe, docker crear\u00e1 el volumen: docker run -it --rm --name testA -v DataVol:/opt/app/data busybox sh Har\u00e1 que el volumen quede presentado dentro del contenedor en la carpeta /opt/app/data . Podemos analizar su configuraci\u00f3n: $ docker volume inspect DataVol [ { \"CreatedAt\": \"2018-06-04T21:31:46Z\", \"Driver\": \"local\", \"Labels\": null, \"Mountpoint\": \"/var/lib/docker/volumes/DataVol/_data\", \"Name\": \"DataVol\", \"Options\": null, \"Scope\": \"local\" } ] Y dentro del contenedor lo podemos consultar con mount: /dev/sda1 on /opt/app/data type ext4 (rw,relatime,data=ordered) Vol\u00famenes an\u00f3nimos Se indica solamente carpeta del contenedor debe ser guardada en el host fuera , en el host. Docker le asignar\u00e1 un ID de volumen y un espacio que permanecer\u00e1 aunque el contenedor sea borrado. docker container run -it -v /data ubuntu bash root@df5e2fce65e7:/# root@df5e2fce65e7:/# touch /data/file.txt root@df5e2fce65e7:/# exit Los datos ( file.txt ) permanecer\u00e1n en un volumen con un ID de identificaci\u00f3n: docker volume ls DRIVER VOLUME NAME local 0de61240ce255aa73af2c57873cc50b9134b49 Y pueden ser vueltos a montar en caso necesario: docker run -it --rm -v 0de61240ce255aa73af2c57873cc50b9134b49:/data ubuntu ls /data file.txt Pero se puede observar que en caso de tener muchos contenedores en uso o apagados, la lista de vol\u00famenes puede ser extensa. Re-utilizar un volumen creado Al volver a correr ( run ) un contenedor con el mismo nombre de volumen volvemos a montarlo y a acceder a sus datos: docker run -it --rm --name testB -v DataVol:/data busybox sh --volumes-from La opci\u00f3n --volumes-from permite utilizar todos los vol\u00famenes que tenga otro contenedor corriendo y montarlos en los mismos puntos de montaje: docker run --rm --volumes-from testB -v $PWD:/backup busybox sh -c 'cp /data/* /backup/' RM / PRUNE Para borrar los vol\u00famenes, puede hacerse: de a uno docker volume rm 0de61240ce255aa73af2c57873cc50 todos docker volume prune al ejecutar con --rm para vol\u00famenes an\u00f3nimos Tambi\u00e9n es posible listar con un filtro y borrar solo esos vol\u00famenes: docker volume rm $(docker volume ls -q --filter dangling=true) Ejercicios: 1. Usando vol\u00famenes, correr la imagen mysql:latest o mongo:latest crear una base de datos y destruir el contenedor. Volver a correr la misma imagen montando el volumen creado anteriormente y verificar que la base de datos se mantenga creada. Referencias: Use volumes","title":"Filesystem del host (volume)"},{"location":"chapter04/02volume/#filesystem-del-host-volume","text":"Los vol\u00famenes es un recurso administrado por docker y que pueden ser vistos como un disco guardado en el host (pseduo-volumen) para montar en los contenedores.","title":"Filesystem del host (volume)"},{"location":"chapter04/02volume/#volumen","text":"Puede ser utilizado por otros contenedores simplemente indicando el nombre del vol\u00famen. La creaci\u00f3n de un volume se puede realizar de dos formas diferentes: al ejecutar docker run creando con nombre docker volume create","title":"Vol\u00famen"},{"location":"chapter04/02volume/#create","text":"Con la opci\u00f3n volume create se puede crear un volumen con un nombre dado, para luego utilizar: docker volume create MisDatos","title":"CREATE"},{"location":"chapter04/02volume/#ls","text":"Y puede ser visto en el listado de vol\u00famenes disponibles: $ docker volume ls DRIVER VOLUME NAME local MisDatos","title":"LS"},{"location":"chapter04/02volume/#-volume-v","text":"Esta opci\u00f3n es semejante a bind mount pues se usa con la opci\u00f3n -v pero se indica un nombre en lugar de un path del host. Si no existe, docker crear\u00e1 el volumen: docker run -it --rm --name testA -v DataVol:/opt/app/data busybox sh Har\u00e1 que el volumen quede presentado dentro del contenedor en la carpeta /opt/app/data . Podemos analizar su configuraci\u00f3n: $ docker volume inspect DataVol [ { \"CreatedAt\": \"2018-06-04T21:31:46Z\", \"Driver\": \"local\", \"Labels\": null, \"Mountpoint\": \"/var/lib/docker/volumes/DataVol/_data\", \"Name\": \"DataVol\", \"Options\": null, \"Scope\": \"local\" } ] Y dentro del contenedor lo podemos consultar con mount: /dev/sda1 on /opt/app/data type ext4 (rw,relatime,data=ordered)","title":"--volume | -v"},{"location":"chapter04/02volume/#volumenes-anonimos","text":"Se indica solamente carpeta del contenedor debe ser guardada en el host fuera , en el host. Docker le asignar\u00e1 un ID de volumen y un espacio que permanecer\u00e1 aunque el contenedor sea borrado. docker container run -it -v /data ubuntu bash root@df5e2fce65e7:/# root@df5e2fce65e7:/# touch /data/file.txt root@df5e2fce65e7:/# exit Los datos ( file.txt ) permanecer\u00e1n en un volumen con un ID de identificaci\u00f3n: docker volume ls DRIVER VOLUME NAME local 0de61240ce255aa73af2c57873cc50b9134b49 Y pueden ser vueltos a montar en caso necesario: docker run -it --rm -v 0de61240ce255aa73af2c57873cc50b9134b49:/data ubuntu ls /data file.txt Pero se puede observar que en caso de tener muchos contenedores en uso o apagados, la lista de vol\u00famenes puede ser extensa.","title":"Vol\u00famenes an\u00f3nimos"},{"location":"chapter04/02volume/#re-utilizar-un-volumen-creado","text":"Al volver a correr ( run ) un contenedor con el mismo nombre de volumen volvemos a montarlo y a acceder a sus datos: docker run -it --rm --name testB -v DataVol:/data busybox sh","title":"Re-utilizar un volumen creado"},{"location":"chapter04/02volume/#-volumes-from","text":"La opci\u00f3n --volumes-from permite utilizar todos los vol\u00famenes que tenga otro contenedor corriendo y montarlos en los mismos puntos de montaje: docker run --rm --volumes-from testB -v $PWD:/backup busybox sh -c 'cp /data/* /backup/'","title":"--volumes-from"},{"location":"chapter04/02volume/#rm-prune","text":"Para borrar los vol\u00famenes, puede hacerse: de a uno docker volume rm 0de61240ce255aa73af2c57873cc50 todos docker volume prune al ejecutar con --rm para vol\u00famenes an\u00f3nimos Tambi\u00e9n es posible listar con un filtro y borrar solo esos vol\u00famenes: docker volume rm $(docker volume ls -q --filter dangling=true)","title":"RM / PRUNE"},{"location":"chapter04/02volume/#ejercicios","text":"","title":"Ejercicios:"},{"location":"chapter04/02volume/#1","text":"Usando vol\u00famenes, correr la imagen mysql:latest o mongo:latest crear una base de datos y destruir el contenedor. Volver a correr la misma imagen montando el volumen creado anteriormente y verificar que la base de datos se mantenga creada.","title":"1."},{"location":"chapter04/02volume/#referencias","text":"Use volumes","title":"Referencias:"},{"location":"chapter04/03tmpfsmount/","text":"Filesystem temporal del host Permite el asignar espacio de memoria del host como filesytem temporal del contenedor. En este caso el filesystem es externo al contenedor y es ef\u00edmero pues se eliminar\u00e1 inclusive cuando el contenedor se detenga . Y no se pueden compartir entre contenedores corriendo. El objetivo de tmpfs mounts es guardar datos sensibles o temporales que no se persisten en la capa de escritura (chroot disponible desde el host). Solamente disponibles en Linux Por ejemplo: docker run -it --name tmpA --tmpfs /app alpine sh Dentro del contenedor queda presentado de esta forma: tmpfs on /app type tmpfs (rw,nosuid,nodev,noexec,relatime) docker inspect tmpA \"Tmpfs\": { \"/app\": \"\" }, Referencias: Use tmpfs mounts","title":"Filesystem temporal del host"},{"location":"chapter04/03tmpfsmount/#filesystem-temporal-del-host","text":"Permite el asignar espacio de memoria del host como filesytem temporal del contenedor. En este caso el filesystem es externo al contenedor y es ef\u00edmero pues se eliminar\u00e1 inclusive cuando el contenedor se detenga . Y no se pueden compartir entre contenedores corriendo. El objetivo de tmpfs mounts es guardar datos sensibles o temporales que no se persisten en la capa de escritura (chroot disponible desde el host). Solamente disponibles en Linux Por ejemplo: docker run -it --name tmpA --tmpfs /app alpine sh Dentro del contenedor queda presentado de esta forma: tmpfs on /app type tmpfs (rw,nosuid,nodev,noexec,relatime) docker inspect tmpA \"Tmpfs\": { \"/app\": \"\" },","title":"Filesystem temporal del host"},{"location":"chapter04/03tmpfsmount/#referencias","text":"Use tmpfs mounts","title":"Referencias:"},{"location":"chapter04/","text":"Filesystem esf\u00edmero Los contenedores tienen un filesystem esf\u00edmero , es decir que estar\u00e1 disponible mientras el contenedor exista. Una vez que el container se borre, el filesystem tambi\u00e9n ser\u00e1 eliminado. Mantener datos Para mantener datos fuera del contenedor existen tres posibilidades: Servicios externos: filesystem remotos storage de objetos bases de datos Filesystem del Host bind mount volumes (docker volume) Memoria del Host (temporal) tmpfs mount Im\u00e1genes y vol\u00famenes Los vol\u00famenes, los bind mount y los tmpfs mount no son parte de las im\u00e1genes que se puedan crear (solo disponibles en runtime ) Referencias: Manage data in Docker","title":"Filesystem esf\u00edmero"},{"location":"chapter04/#filesystem-esfimero","text":"Los contenedores tienen un filesystem esf\u00edmero , es decir que estar\u00e1 disponible mientras el contenedor exista. Una vez que el container se borre, el filesystem tambi\u00e9n ser\u00e1 eliminado.","title":"Filesystem esf\u00edmero"},{"location":"chapter04/#mantener-datos","text":"Para mantener datos fuera del contenedor existen tres posibilidades: Servicios externos: filesystem remotos storage de objetos bases de datos Filesystem del Host bind mount volumes (docker volume) Memoria del Host (temporal) tmpfs mount","title":"Mantener datos"},{"location":"chapter04/#imagenes-y-volumenes","text":"Los vol\u00famenes, los bind mount y los tmpfs mount no son parte de las im\u00e1genes que se puedan crear (solo disponibles en runtime )","title":"Im\u00e1genes y vol\u00famenes"},{"location":"chapter04/#referencias","text":"Manage data in Docker","title":"Referencias:"},{"location":"chapter05/01redcerrado/","text":"Contenedores cerrados Los procesos que corren dentro de un mismo contenedor pueden comunicarse entre ellos mediante la interfaz loopback (localhost). Pero en los contenedores cerrados no hay comunicaci\u00f3n ni saliente ni entrante al contenedor; es decir el contenedor no se puede comunicar ni con internet ni con otros contenedores. --network none Para crear un contenedor en una red cerrada utilizamos el argumento --network none cuando lo creamos: docker run --rm --network none -it alpine:latest /bin/sh Este ejemplo abre un shell, pero podr\u00edamos asignarle comandos o tareas ya automatizadas en la imagen que levantamos. Son interesantes para: --volumes-from Procesamiento batch de datos locales --volumes Referencias: Disable networking for a container","title":"Contenedores cerrados"},{"location":"chapter05/01redcerrado/#contenedores-cerrados","text":"Los procesos que corren dentro de un mismo contenedor pueden comunicarse entre ellos mediante la interfaz loopback (localhost). Pero en los contenedores cerrados no hay comunicaci\u00f3n ni saliente ni entrante al contenedor; es decir el contenedor no se puede comunicar ni con internet ni con otros contenedores.","title":"Contenedores cerrados"},{"location":"chapter05/01redcerrado/#-network-none","text":"Para crear un contenedor en una red cerrada utilizamos el argumento --network none cuando lo creamos: docker run --rm --network none -it alpine:latest /bin/sh Este ejemplo abre un shell, pero podr\u00edamos asignarle comandos o tareas ya automatizadas en la imagen que levantamos. Son interesantes para: --volumes-from Procesamiento batch de datos locales --volumes","title":"--network none"},{"location":"chapter05/01redcerrado/#referencias","text":"Disable networking for a container","title":"Referencias:"},{"location":"chapter05/02redabierto/","text":"Contenedores abiertos Los contenedores abiertos se deben evitar en lo posible . Los contenedores abiertos se conectan directamente al sistema de red del host. Para los contenedores abiertos se deben tomar precauciones de aislamiento adicional, ya que se tiene un acceso total a las redes y las interfaces el host. --network host Para crear un contenedor en una red abierta utilizamos el argumento --network host cuando lo creamos: $ docker run --network host -it alpine:latest /bin/sh / # ip a s 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 02:e4:ac:f5:39:a9 brd ff:ff:ff:ff:ff:ff inet 10.0.2.15/24 brd 10.0.2.255 scope global enp0s3 valid_lft forever preferred_lft forever inet6 fe80::e4:acff:fef5:39a9/64 scope link valid_lft forever preferred_lft forever 3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN link/ether 02:42:59:1a:e2:84 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:59ff:fe1a:e284/64 scope link valid_lft forever preferred_lft forever Este container solamente ejecuta un shell, pero muestra como se tiene acceso a todas las interfaces del host en forma transparente. Referencias: Use host networking","title":"Contenedores abiertos"},{"location":"chapter05/02redabierto/#contenedores-abiertos","text":"Los contenedores abiertos se deben evitar en lo posible . Los contenedores abiertos se conectan directamente al sistema de red del host. Para los contenedores abiertos se deben tomar precauciones de aislamiento adicional, ya que se tiene un acceso total a las redes y las interfaces el host.","title":"Contenedores abiertos"},{"location":"chapter05/02redabierto/#-network-host","text":"Para crear un contenedor en una red abierta utilizamos el argumento --network host cuando lo creamos: $ docker run --network host -it alpine:latest /bin/sh / # ip a s 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 02:e4:ac:f5:39:a9 brd ff:ff:ff:ff:ff:ff inet 10.0.2.15/24 brd 10.0.2.255 scope global enp0s3 valid_lft forever preferred_lft forever inet6 fe80::e4:acff:fef5:39a9/64 scope link valid_lft forever preferred_lft forever 3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN link/ether 02:42:59:1a:e2:84 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:59ff:fe1a:e284/64 scope link valid_lft forever preferred_lft forever Este container solamente ejecuta un shell, pero muestra como se tiene acceso a todas las interfaces del host en forma transparente.","title":"--network host"},{"location":"chapter05/02redabierto/#referencias","text":"Use host networking","title":"Referencias:"},{"location":"chapter05/03redbridge/","text":"Contenedores detr\u00e1s de bridges Es la configuraci\u00f3n de red por defecto en docker. Cuando se corre Docker Daemon se crea un bridge ( docker0 ) y los contenedores que se van creando son autom\u00e1ticamente conectados a ese bridge y se le asigna una IP privada. La comunicaci\u00f3n entre contenedores conectados al mismo bridge se produce por estar en la misma sub-red. La conexi\u00f3n hacia internet se produce mediante NAT utilizando la IP p\u00fablica del host. NETWORK Docker permite la creaci\u00f3n de bridges y sub-redes mediante el comando docker network Para crear un contenedor en una detr\u00e1s de un bridge no se necesita indicar ning\u00fan argumento, ya que es el tipo de contenedor que se levanta por defecto. Sin embargo, se puede especificar el argumento --network bridge al crear el contenedor: $ docker run -it alpine:latest /bin/sh / # ip a s 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 70: eth0@if71: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue state UP link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever $ docker run --net bridge alpine:latest Crear una red y bridge Es posible crear una propia red con un bridge e indicarle a docker que la use, en lugar de utilizar la que configura por defecto (docker0). Para crear una nueva red de tipo bridge cualquiera de estos tres comandos es equivalente: CREATE docker network create mired Para crear un bridge con toda la configuraci\u00f3n de red necesaria: docker network create \\ --driver bridge \\ --subnet=192.168.2.0/24 \\ --gateway=192.168.2.10 \\ nueva_red Para correr un contenedor pegado a nuestra nueva sub-red: docker run --network=nueva_red -it --rm --name=brA alpine sh CONNECT / DISCONNECT Es posible conectar un contenedor a una segunda red pre-existente: docker network connect mired brA Y se puede ver con inspect : docker container inspect brA \"Networks\": { \"mired\": { \"nueva_red\": { Multiples redes Actualmente no es posible correr un contenedor con dos redes en el comando run . El proceso es run + connect . En una aplicaci\u00f3n se pueden definir multiples redes para lograr una aislaci\u00f3n a nivel de red frontend service backend En cuyo caso los contenedores deben estar presentados en ambas redes si conectan con otros contenedores de ellas. Referencias: Use bridge networks https://docs.docker.com/engine/reference/commandline/network_create/","title":"Contenedores detr\u00e1s de bridges"},{"location":"chapter05/03redbridge/#contenedores-detras-de-bridges","text":"Es la configuraci\u00f3n de red por defecto en docker. Cuando se corre Docker Daemon se crea un bridge ( docker0 ) y los contenedores que se van creando son autom\u00e1ticamente conectados a ese bridge y se le asigna una IP privada. La comunicaci\u00f3n entre contenedores conectados al mismo bridge se produce por estar en la misma sub-red. La conexi\u00f3n hacia internet se produce mediante NAT utilizando la IP p\u00fablica del host.","title":"Contenedores detr\u00e1s de bridges"},{"location":"chapter05/03redbridge/#network","text":"Docker permite la creaci\u00f3n de bridges y sub-redes mediante el comando docker network Para crear un contenedor en una detr\u00e1s de un bridge no se necesita indicar ning\u00fan argumento, ya que es el tipo de contenedor que se levanta por defecto. Sin embargo, se puede especificar el argumento --network bridge al crear el contenedor: $ docker run -it alpine:latest /bin/sh / # ip a s 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 70: eth0@if71: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue state UP link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever $ docker run --net bridge alpine:latest","title":"NETWORK"},{"location":"chapter05/03redbridge/#crear-una-red-y-bridge","text":"Es posible crear una propia red con un bridge e indicarle a docker que la use, en lugar de utilizar la que configura por defecto (docker0). Para crear una nueva red de tipo bridge cualquiera de estos tres comandos es equivalente:","title":"Crear una red y bridge"},{"location":"chapter05/03redbridge/#create","text":"docker network create mired Para crear un bridge con toda la configuraci\u00f3n de red necesaria: docker network create \\ --driver bridge \\ --subnet=192.168.2.0/24 \\ --gateway=192.168.2.10 \\ nueva_red Para correr un contenedor pegado a nuestra nueva sub-red: docker run --network=nueva_red -it --rm --name=brA alpine sh","title":"CREATE"},{"location":"chapter05/03redbridge/#connect-disconnect","text":"Es posible conectar un contenedor a una segunda red pre-existente: docker network connect mired brA Y se puede ver con inspect : docker container inspect brA \"Networks\": { \"mired\": { \"nueva_red\": {","title":"CONNECT / DISCONNECT"},{"location":"chapter05/03redbridge/#multiples-redes","text":"Actualmente no es posible correr un contenedor con dos redes en el comando run . El proceso es run + connect . En una aplicaci\u00f3n se pueden definir multiples redes para lograr una aislaci\u00f3n a nivel de red frontend service backend En cuyo caso los contenedores deben estar presentados en ambas redes si conectan con otros contenedores de ellas.","title":"Multiples redes"},{"location":"chapter05/03redbridge/#referencias","text":"Use bridge networks https://docs.docker.com/engine/reference/commandline/network_create/","title":"Referencias:"},{"location":"chapter05/04redjuntos/","text":"Contenedores juntos (linked) En una red de contenedores juntos, multiple contenedores comparten la misma interfaz de red loopback , de esta forma, cualquiera que levante un servicio en 127.0.0.1 ser\u00e1 visto por el otro en su respectivo localhost . De esta forma se pueden crear containers aislados de internet pero vinculados por red entre ellos redes. Para crear un contenedor unido a otro utilizamos el argumento --network container:nombre , como este ejemplo: Creamos un primer contenedor en una cerrado: $ docker run --rm --name 1cerrado --network none -it alpine /bin/sh Creamos un segundo contenedor peg\u00e1ndolo al creado en el paso anterior: $ docker run --rm --network container:1cerrado -it alpine /bin/sh Referencias: Network containers","title":"Contenedores juntos (linked)"},{"location":"chapter05/04redjuntos/#contenedores-juntos-linked","text":"En una red de contenedores juntos, multiple contenedores comparten la misma interfaz de red loopback , de esta forma, cualquiera que levante un servicio en 127.0.0.1 ser\u00e1 visto por el otro en su respectivo localhost . De esta forma se pueden crear containers aislados de internet pero vinculados por red entre ellos redes. Para crear un contenedor unido a otro utilizamos el argumento --network container:nombre , como este ejemplo: Creamos un primer contenedor en una cerrado: $ docker run --rm --name 1cerrado --network none -it alpine /bin/sh Creamos un segundo contenedor peg\u00e1ndolo al creado en el paso anterior: $ docker run --rm --network container:1cerrado -it alpine /bin/sh","title":"Contenedores juntos (linked)"},{"location":"chapter05/04redjuntos/#referencias","text":"Network containers","title":"Referencias:"},{"location":"chapter05/05accesoexterno/","text":"Acceso externo Los contenedores presentados en el mismo bridge exponen entre ellos todos los puertos que tienen abiertos, pero ninguno de esos puertos son accesibles desde fuera de la red del bridge . Es posible presentar en un puerto del host que corresponde a un puerto en particular del contenedor (DNAT), cuando se utiliza red bridge . --publish | -p Para publicar un puerto del host (LISTEN) que tiene una configuraci\u00f3n que mapa un puerto del contenedor (DNAT) se hace al levantar el contenedor: docker run --rm -it --publish 8080:80 -d nginx:latest curl localhost:8080 <!DOCTYPE html> <html> <head> <title>Welcome to nginx!</title> La opci\u00f3n EXPOSE de las im\u00e1genes permite conocer qu\u00e9 puertos tendr\u00e1n un servicio escuchando cuando el contenedor est\u00e9 corriendo. Uso nombre Redes creadas por el usuario Por defecto los contenedores en redes creadas por el usuario mapean en el DNS todos por nombre entre ellos. docker run --rm -it --network mired --name testA alpine sh docker run --rm -it --network mired --name testB alpine sh # ping testA PING testA (172.18.0.2): 56 data bytes 64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.099 ms 64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.094 ms Bridge por defecto docker0 En el bridge por defecto (docker0) es necesario usar la opci\u00f3n --link para que se vinculen los nombres entre los contenedores y genera entradas en el archivo /etc/hosts para resolver los container por nombre entre ellos. --link se utiliza solamente para el default bridge (docker0) --link es una opci\u00f3n caduca y ser\u00e1 retirada en versi\u00f3n futura Referencias: Use bridge networks","title":"Acceso externo"},{"location":"chapter05/05accesoexterno/#acceso-externo","text":"Los contenedores presentados en el mismo bridge exponen entre ellos todos los puertos que tienen abiertos, pero ninguno de esos puertos son accesibles desde fuera de la red del bridge . Es posible presentar en un puerto del host que corresponde a un puerto en particular del contenedor (DNAT), cuando se utiliza red bridge .","title":"Acceso externo"},{"location":"chapter05/05accesoexterno/#-publish-p","text":"Para publicar un puerto del host (LISTEN) que tiene una configuraci\u00f3n que mapa un puerto del contenedor (DNAT) se hace al levantar el contenedor: docker run --rm -it --publish 8080:80 -d nginx:latest curl localhost:8080 <!DOCTYPE html> <html> <head> <title>Welcome to nginx!</title> La opci\u00f3n EXPOSE de las im\u00e1genes permite conocer qu\u00e9 puertos tendr\u00e1n un servicio escuchando cuando el contenedor est\u00e9 corriendo.","title":"--publish | -p"},{"location":"chapter05/05accesoexterno/#uso-nombre","text":"","title":"Uso nombre"},{"location":"chapter05/05accesoexterno/#redes-creadas-por-el-usuario","text":"Por defecto los contenedores en redes creadas por el usuario mapean en el DNS todos por nombre entre ellos. docker run --rm -it --network mired --name testA alpine sh docker run --rm -it --network mired --name testB alpine sh # ping testA PING testA (172.18.0.2): 56 data bytes 64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.099 ms 64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.094 ms","title":"Redes creadas por el usuario"},{"location":"chapter05/05accesoexterno/#bridge-por-defecto-docker0","text":"En el bridge por defecto (docker0) es necesario usar la opci\u00f3n --link para que se vinculen los nombres entre los contenedores y genera entradas en el archivo /etc/hosts para resolver los container por nombre entre ellos. --link se utiliza solamente para el default bridge (docker0) --link es una opci\u00f3n caduca y ser\u00e1 retirada en versi\u00f3n futura","title":"Bridge por defecto docker0"},{"location":"chapter05/05accesoexterno/#referencias","text":"Use bridge networks","title":"Referencias:"},{"location":"chapter05/","text":"Redes de contenedores Los contenedores suponen aislaci\u00f3n, por lo que para vincularlos tenemos cuatro tipos de opciones o formas de vinculaci\u00f3n. Contenedores cerrados ( none ) Contenedores abiertos ( host ) Contenedores detr\u00e1s de bridges ( bridge ) Contenedores juntos ( container ) Docker ofrece un sistema muy flexible de red, que permite crear nuestra propia configuraci\u00f3n, para atender necesidades espec\u00edficas. El comando network ls mostrar\u00e1 las redes disponibles $ docker network ls NETWORK ID NAME DRIVER SCOPE 67bf7f355a4e bridge bridge local 727420fae124 host host local fa2601d6c7fa none null local","title":"Redes de contenedores"},{"location":"chapter05/#redes-de-contenedores","text":"Los contenedores suponen aislaci\u00f3n, por lo que para vincularlos tenemos cuatro tipos de opciones o formas de vinculaci\u00f3n. Contenedores cerrados ( none ) Contenedores abiertos ( host ) Contenedores detr\u00e1s de bridges ( bridge ) Contenedores juntos ( container ) Docker ofrece un sistema muy flexible de red, que permite crear nuestra propia configuraci\u00f3n, para atender necesidades espec\u00edficas. El comando network ls mostrar\u00e1 las redes disponibles $ docker network ls NETWORK ID NAME DRIVER SCOPE 67bf7f355a4e bridge bridge local 727420fae124 host host local fa2601d6c7fa none null local","title":"Redes de contenedores"},{"location":"chapter06/02docker-compose/","text":"docker-compose Compose es una herramienta que define y corre aplicaciones basadas en m\u00faltiples contenedores con Docker. La definici\u00f3n se realiza en un \u00fanico archivo y se lanzan los m\u00faltiples contenedores en un \u00fanico comando, que realiza todo lo que se tenga que hacer para correr los m\u00faltiples contenedores. Utilizando el ejemplo de Wordpress de la secci\u00f3n anterior definen los servicios y redes en un \u00fanico docker-compose.yml version: '3' services: # docker run \\ # -e MYSQL_ROOT_PASSWORD=rootpass \\ # --name wpdb \\ # --network wp \\ # -v \"$PWD/database\":/var/lib/mysql \\ # -d mariadb:latest wpdb: image: mariadb:latest container_name: wpdb volumes: - $PWD/database:/var/lib/mysql environment: - MYSQL_ROOT_PASSWORD=rootpass networks: - wp # docker run \\ # -e WORDPRESS_DB_PASSWORD=rootpass \\ # -e WORDPRESS_DB_HOST=wpdb \\ # --name wordpress \\ # --network wp \\ # -p 8081:80 \\ # -v \"$PWD/html\":/var/www/html \\ # -d wordpress wordpress: depends_on: - wpdb image: wordpress container_name: wordpress networks: - wp ports: - \"8081:80\" volumes: - $PWD/html:/var/www/html environment: - WORDPRESS_DB_PASSWORD=rootpass - WORDPRESS_DB_HOST=wpdb networks: wp: UP Se lanza la aplicaci\u00f3n con la opci\u00f3n up y opcionalmente -d para que ejecute detached de la consola: $ docker-compose up -d Creating network \"wp_wp\" with the default driver Creating wpdb ... Creating wpdb ... done Creating wordpress ... Creating wordpress ... done PS $ docker-compose ps Name Command State Ports ------------------------------------------------------------------------- wordpress docker-entrypoint.sh apach ... Up 0.0.0.0:8081->80/tcp wpdb docker-entrypoint.sh mysqld Up 3306/tcp STOP / START / RESTART Compose nos permite detener, iniciar o reiniciar nuestra aplicaci\u00f3n en m\u00faltiples contenedores con un \u00fanico comando DOWN La opci\u00f3n down detiene la aplicaci\u00f3n y borra todos los recursos definidos en el docker-compose.yml $ docker-compose down Stopping wordpress ... done Stopping wpdb ... done Removing wordpress ... done Removing wpdb ... done Removing network wp_wp Comandos docker no disponibles Existen comandos docker que no est\u00e1n disponibles para usar en docker-compose , esos comandos son: Los comandos de administraci\u00f3n como: save, search, images, import, export, tag, history Los comandos de interacci\u00f3n con el usuario como attach, exec, login, wait Ejercicios 1. Basados en la imagen tomcat que escucha en el puerto 8080. Crear. un docker-compose.yml para levantar una aplicaci\u00f3n tomcat del ejemplo Sample Application 2. Utilizando la aplicaci\u00f3n cloud native traefik configurar un proxy reverso para la aplicaci\u00f3n del ejercicio 1 que escuche en el puerto 80 (u otro que prefiera) Imagen: traefik:latest Referencias: Overview of Docker Compose Compose file version 3 reference","title":"docker-compose"},{"location":"chapter06/02docker-compose/#docker-compose","text":"Compose es una herramienta que define y corre aplicaciones basadas en m\u00faltiples contenedores con Docker. La definici\u00f3n se realiza en un \u00fanico archivo y se lanzan los m\u00faltiples contenedores en un \u00fanico comando, que realiza todo lo que se tenga que hacer para correr los m\u00faltiples contenedores. Utilizando el ejemplo de Wordpress de la secci\u00f3n anterior definen los servicios y redes en un \u00fanico docker-compose.yml version: '3' services: # docker run \\ # -e MYSQL_ROOT_PASSWORD=rootpass \\ # --name wpdb \\ # --network wp \\ # -v \"$PWD/database\":/var/lib/mysql \\ # -d mariadb:latest wpdb: image: mariadb:latest container_name: wpdb volumes: - $PWD/database:/var/lib/mysql environment: - MYSQL_ROOT_PASSWORD=rootpass networks: - wp # docker run \\ # -e WORDPRESS_DB_PASSWORD=rootpass \\ # -e WORDPRESS_DB_HOST=wpdb \\ # --name wordpress \\ # --network wp \\ # -p 8081:80 \\ # -v \"$PWD/html\":/var/www/html \\ # -d wordpress wordpress: depends_on: - wpdb image: wordpress container_name: wordpress networks: - wp ports: - \"8081:80\" volumes: - $PWD/html:/var/www/html environment: - WORDPRESS_DB_PASSWORD=rootpass - WORDPRESS_DB_HOST=wpdb networks: wp:","title":"docker-compose"},{"location":"chapter06/02docker-compose/#up","text":"Se lanza la aplicaci\u00f3n con la opci\u00f3n up y opcionalmente -d para que ejecute detached de la consola: $ docker-compose up -d Creating network \"wp_wp\" with the default driver Creating wpdb ... Creating wpdb ... done Creating wordpress ... Creating wordpress ... done","title":"UP"},{"location":"chapter06/02docker-compose/#ps","text":"$ docker-compose ps Name Command State Ports ------------------------------------------------------------------------- wordpress docker-entrypoint.sh apach ... Up 0.0.0.0:8081->80/tcp wpdb docker-entrypoint.sh mysqld Up 3306/tcp","title":"PS"},{"location":"chapter06/02docker-compose/#stop-start-restart","text":"Compose nos permite detener, iniciar o reiniciar nuestra aplicaci\u00f3n en m\u00faltiples contenedores con un \u00fanico comando","title":"STOP / START / RESTART"},{"location":"chapter06/02docker-compose/#down","text":"La opci\u00f3n down detiene la aplicaci\u00f3n y borra todos los recursos definidos en el docker-compose.yml $ docker-compose down Stopping wordpress ... done Stopping wpdb ... done Removing wordpress ... done Removing wpdb ... done Removing network wp_wp","title":"DOWN"},{"location":"chapter06/02docker-compose/#comandos-docker-no-disponibles","text":"Existen comandos docker que no est\u00e1n disponibles para usar en docker-compose , esos comandos son: Los comandos de administraci\u00f3n como: save, search, images, import, export, tag, history Los comandos de interacci\u00f3n con el usuario como attach, exec, login, wait","title":"Comandos docker no disponibles"},{"location":"chapter06/02docker-compose/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter06/02docker-compose/#1","text":"Basados en la imagen tomcat que escucha en el puerto 8080. Crear. un docker-compose.yml para levantar una aplicaci\u00f3n tomcat del ejemplo Sample Application","title":"1."},{"location":"chapter06/02docker-compose/#2","text":"Utilizando la aplicaci\u00f3n cloud native traefik configurar un proxy reverso para la aplicaci\u00f3n del ejercicio 1 que escuche en el puerto 80 (u otro que prefiera) Imagen: traefik:latest Referencias: Overview of Docker Compose Compose file version 3 reference","title":"2."},{"location":"chapter06/03docker-compose-workflow/","text":"Docker compose workflow En general se suelen realizar tres pasos para definir una aplicaci\u00f3n en docker-compose Definir cada servicio en un Dockerfile Definir la relaci\u00f3n entre los servicios y c\u00f3mo ellos se ejecutan (entorno, vol\u00famenes, redes) en docker-compose.yml Lanzar la aplicaci\u00f3n con docker-compose up Veamos c\u00f3mo usar esta definici\u00f3n de aplicaci\u00f3n en un entorno de trabajo de un proyecto real: Estructura b\u00e1sica Estructura con entornos","title":"Docker compose workflow"},{"location":"chapter06/03docker-compose-workflow/#docker-compose-workflow","text":"En general se suelen realizar tres pasos para definir una aplicaci\u00f3n en docker-compose Definir cada servicio en un Dockerfile Definir la relaci\u00f3n entre los servicios y c\u00f3mo ellos se ejecutan (entorno, vol\u00famenes, redes) en docker-compose.yml Lanzar la aplicaci\u00f3n con docker-compose up Veamos c\u00f3mo usar esta definici\u00f3n de aplicaci\u00f3n en un entorno de trabajo de un proyecto real: Estructura b\u00e1sica Estructura con entornos","title":"Docker compose workflow"},{"location":"chapter06/04basica/","text":"Estructura b\u00e1sica Una estructura b\u00e1sica para un sitio con una aplicaci\u00f3n que es un api de un proyecto llamado consola-control llevar\u00eda una estructura b\u00e1sica: consola-control/ \u251c\u2500\u2500 api \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u251c\u2500\u2500 package.json \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.js \u2514\u2500\u2500 docker-compose.yml El archivo api/Dockerfile tendr\u00eda el siguiente contenido: FROM node:8 WORKDIR /usr/src/app COPY package*.json ./ RUN npm install COPY . . EXPOSE 8080 CMD [ \"npm\", \"start\" ] La imagen creada es aut\u00f3noma y es capaz de poner a funcionar el servicio del api . El archivo docker-compose.yml se encargar\u00eda de levantar todo lo que requiere la aplicaci\u00f3n consola-control para funcionar: services: frontend: build: api links: - backend:redis ports: - 8081:8081 environment: - VAR1=value networks: - consola-control depends_on: - backend restart: always backend: image: redis:3 networks: - consola-control restart: always networks: consola-control:","title":"Estructura b\u00e1sica"},{"location":"chapter06/04basica/#estructura-basica","text":"Una estructura b\u00e1sica para un sitio con una aplicaci\u00f3n que es un api de un proyecto llamado consola-control llevar\u00eda una estructura b\u00e1sica: consola-control/ \u251c\u2500\u2500 api \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u251c\u2500\u2500 package.json \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.js \u2514\u2500\u2500 docker-compose.yml El archivo api/Dockerfile tendr\u00eda el siguiente contenido: FROM node:8 WORKDIR /usr/src/app COPY package*.json ./ RUN npm install COPY . . EXPOSE 8080 CMD [ \"npm\", \"start\" ] La imagen creada es aut\u00f3noma y es capaz de poner a funcionar el servicio del api . El archivo docker-compose.yml se encargar\u00eda de levantar todo lo que requiere la aplicaci\u00f3n consola-control para funcionar: services: frontend: build: api links: - backend:redis ports: - 8081:8081 environment: - VAR1=value networks: - consola-control depends_on: - backend restart: always backend: image: redis:3 networks: - consola-control restart: always networks: consola-control:","title":"Estructura b\u00e1sica"},{"location":"chapter06/05entornos/","text":"Estructura con entornos Ahora vemos el proyecto consola-control pero mantenido en dos entornos: development production y su estructura quedar\u00eda de la siguiente forma: consola-control/ \u251c\u2500\u2500 common \u2502 \u2514\u2500\u2500 docker-compose.yml \u2502 \u2514\u2500\u2500 nginx.conf \u251c\u2500\u2500 development \u2502 \u251c\u2500\u2500 api \u2502 \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u2502 \u251c\u2500\u2500 package.json \u2502 \u2502 \u2514\u2500\u2500 src \u2502 \u2502 \u2514\u2500\u2500 index.js \u2502 \u2514\u2500\u2500 docker-compose.yml \u2514\u2500\u2500 production \u251c\u2500\u2500 api \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u251c\u2500\u2500 package.json \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.js \u2514\u2500\u2500 docker-compose.yml Development El common/docker-compose.yml levanta el proxy reverso solamente que es com\u00fan a ambos entornos web: image: nginx ports: - 8082:80 volumes: - nginx.conf:/etc/nginx/nginx.conf El development/docker-compose.yml extiende common , presenta el filesystem del host en el dentro del contenedor (para seguir desarrollando) y utiliza redis desde el host. web: extends: file: ../common/docker-compose.yml service: web volumes_from: - api links: - api:8080 api: build: api volumes: - .:/usr/src/app Para crear la imagen el development/api/Dockerfile no copia los c\u00f3digos dentro, ya que ser\u00e1n montados al lanzar el entorno. FROM node:8 WORKDIR /usr/src/app COPY package*.json ./ RUN npm install CMD [ \"npm\", \"start\" ] Para lanzar el entorno, solamente ejecutar: cd development docker-compose up -d Producci\u00f3n El production/docker-compose.yml extiende common pero utiliza la imagen completa, adem\u00e1s de tener el servicio redis: services: frontend: extends: file: ../common/docker-compose.yml service: web build: api links: - backend:redis environment: - VAR1=value networks: - consola-control depends_on: - backend restart: always backend: image: redis:3 networks: - consola-control restart: always networks: consola-control: Y el archivo production/api/Dockerfile es el mismo del cap\u00edtulo anterior, donde todo el c\u00f3digo es COPY a la imagen antes de lanzarla. FROM node:8 MAINTAINER Great Dev <gd@fix-it.com> WORKDIR /usr/src/app COPY package*.json ./ RUN npm install COPY . . EXPOSE 8080 CMD [ \"npm\", \"start\" ]","title":"Estructura con entornos"},{"location":"chapter06/05entornos/#estructura-con-entornos","text":"Ahora vemos el proyecto consola-control pero mantenido en dos entornos: development production y su estructura quedar\u00eda de la siguiente forma: consola-control/ \u251c\u2500\u2500 common \u2502 \u2514\u2500\u2500 docker-compose.yml \u2502 \u2514\u2500\u2500 nginx.conf \u251c\u2500\u2500 development \u2502 \u251c\u2500\u2500 api \u2502 \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u2502 \u251c\u2500\u2500 package.json \u2502 \u2502 \u2514\u2500\u2500 src \u2502 \u2502 \u2514\u2500\u2500 index.js \u2502 \u2514\u2500\u2500 docker-compose.yml \u2514\u2500\u2500 production \u251c\u2500\u2500 api \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u251c\u2500\u2500 package.json \u2502 \u2514\u2500\u2500 src \u2502 \u2514\u2500\u2500 index.js \u2514\u2500\u2500 docker-compose.yml","title":"Estructura con entornos"},{"location":"chapter06/05entornos/#development","text":"El common/docker-compose.yml levanta el proxy reverso solamente que es com\u00fan a ambos entornos web: image: nginx ports: - 8082:80 volumes: - nginx.conf:/etc/nginx/nginx.conf El development/docker-compose.yml extiende common , presenta el filesystem del host en el dentro del contenedor (para seguir desarrollando) y utiliza redis desde el host. web: extends: file: ../common/docker-compose.yml service: web volumes_from: - api links: - api:8080 api: build: api volumes: - .:/usr/src/app Para crear la imagen el development/api/Dockerfile no copia los c\u00f3digos dentro, ya que ser\u00e1n montados al lanzar el entorno. FROM node:8 WORKDIR /usr/src/app COPY package*.json ./ RUN npm install CMD [ \"npm\", \"start\" ] Para lanzar el entorno, solamente ejecutar: cd development docker-compose up -d","title":"Development"},{"location":"chapter06/05entornos/#produccion","text":"El production/docker-compose.yml extiende common pero utiliza la imagen completa, adem\u00e1s de tener el servicio redis: services: frontend: extends: file: ../common/docker-compose.yml service: web build: api links: - backend:redis environment: - VAR1=value networks: - consola-control depends_on: - backend restart: always backend: image: redis:3 networks: - consola-control restart: always networks: consola-control: Y el archivo production/api/Dockerfile es el mismo del cap\u00edtulo anterior, donde todo el c\u00f3digo es COPY a la imagen antes de lanzarla. FROM node:8 MAINTAINER Great Dev <gd@fix-it.com> WORKDIR /usr/src/app COPY package*.json ./ RUN npm install COPY . . EXPOSE 8080 CMD [ \"npm\", \"start\" ]","title":"Producci\u00f3n"},{"location":"chapter06/","text":"Multiple contenedores Como los contenedores est\u00e1n pensados para ejecutar un \u00fanico proceso/daemon lo normal es utilizar m\u00faltiples contenedores para cada proceso que requiere nuestra aplicaci\u00f3n. La tendencia es descomponer nuestra aplicaci\u00f3n en microservicios que permiten desarrollos independientes y gesti\u00f3n independientes, que se levantan orquestados en conjunto para que la aplicaci\u00f3n quede corriendo. Ejecutar m\u00faltiples contenedores vinculados El siguiente ejemplo muestra un contenedor la aplicaci\u00f3n Wordpress en m\u00faltiples contenedores: Contenedor wordpress levanta un servicio web y el int\u00e9rprete PHP. Contenedor wpdb corre la base de datos MySQL requerida por Wordpress para archivar sus datos docker network create wp mkdir -p wp/database wp/html; cd wp docker run \\ -e MYSQL_ROOT_PASSWORD=rootpass \\ --name wpdb \\ --network wp \\ -v \"$PWD/database\":/var/lib/mysql \\ -d mariadb:latest docker run \\ -e WORDPRESS_DB_PASSWORD=rootpass \\ -e WORDPRESS_DB_HOST=wpdb \\ --name wordpress \\ --network wp \\ -p 8081:80 \\ -v \"$PWD/html\":/var/www/html \\ -d wordpress En el siguiente ejemplo se muestra c\u00f3mo ser\u00eda el arranque si se utilizara el bridge default utilizando la opci\u00f3n --link : docker run \\ -e WORDPRESS_DB_PASSWORD=rootpass \\ --name wordpress \\ --link wpdb:mysql \\ -p 8081:80 \\ -v \"$PWD/html\":/var/www/html \\ -d wordpress LOGS Se puede verificar el funcionamiento de un contenedor revisando su log: docker logs wordpress Borrar aplicaci\u00f3n Y para borrar estos aplicaci\u00f3n debemos ejecutar: docker container stop wordpress wpdb docker container rm wordpress wpdb docker network rm wp Y los datos quedar\u00e1n en las carpetas montadas.","title":"Multiple contenedores"},{"location":"chapter06/#multiple-contenedores","text":"Como los contenedores est\u00e1n pensados para ejecutar un \u00fanico proceso/daemon lo normal es utilizar m\u00faltiples contenedores para cada proceso que requiere nuestra aplicaci\u00f3n. La tendencia es descomponer nuestra aplicaci\u00f3n en microservicios que permiten desarrollos independientes y gesti\u00f3n independientes, que se levantan orquestados en conjunto para que la aplicaci\u00f3n quede corriendo.","title":"Multiple contenedores"},{"location":"chapter06/#ejecutar-multiples-contenedores-vinculados","text":"El siguiente ejemplo muestra un contenedor la aplicaci\u00f3n Wordpress en m\u00faltiples contenedores: Contenedor wordpress levanta un servicio web y el int\u00e9rprete PHP. Contenedor wpdb corre la base de datos MySQL requerida por Wordpress para archivar sus datos docker network create wp mkdir -p wp/database wp/html; cd wp docker run \\ -e MYSQL_ROOT_PASSWORD=rootpass \\ --name wpdb \\ --network wp \\ -v \"$PWD/database\":/var/lib/mysql \\ -d mariadb:latest docker run \\ -e WORDPRESS_DB_PASSWORD=rootpass \\ -e WORDPRESS_DB_HOST=wpdb \\ --name wordpress \\ --network wp \\ -p 8081:80 \\ -v \"$PWD/html\":/var/www/html \\ -d wordpress En el siguiente ejemplo se muestra c\u00f3mo ser\u00eda el arranque si se utilizara el bridge default utilizando la opci\u00f3n --link : docker run \\ -e WORDPRESS_DB_PASSWORD=rootpass \\ --name wordpress \\ --link wpdb:mysql \\ -p 8081:80 \\ -v \"$PWD/html\":/var/www/html \\ -d wordpress","title":"Ejecutar m\u00faltiples contenedores vinculados"},{"location":"chapter06/#logs","text":"Se puede verificar el funcionamiento de un contenedor revisando su log: docker logs wordpress","title":"LOGS"},{"location":"chapter06/#borrar-aplicacion","text":"Y para borrar estos aplicaci\u00f3n debemos ejecutar: docker container stop wordpress wpdb docker container rm wordpress wpdb docker network rm wp Y los datos quedar\u00e1n en las carpetas montadas.","title":"Borrar aplicaci\u00f3n"}]}