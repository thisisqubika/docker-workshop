{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Docker - Gu\u00eda del Usuario Bienvenidos a la gu\u00eda para el usuario Docker. Su intenci\u00f3n es ser manual de referencia y gu\u00eda de aprendizaje b\u00e1sico, es decir llevar r\u00e1pidamente al uso de Docker sin demasiado \u00e9nfasis en fundamentos o explicaciones de por qu\u00e9 suceden las cosas. C\u00f3mo utilizar esta gu\u00eda Esta gu\u00eda est\u00e1 redactada en markdown y puede ser clonada a su disco para hacerle las modificaciones y mejoras que deseen. La gu\u00eda puede ser le\u00edda en forma secuencial o aleatorea, de acuerdo a las necesidades de cada uno A qui\u00e9n va dirigida esta gu\u00eda Inicialmente a cualquiera que est\u00e9 interesado en Docker. No es una gu\u00eda b\u00e1sica, a pesar que empieza desde usos b\u00e1sicos de Docker, se recomienda entender los conceptos de contenedores en Linux y, obviamente, comprender los principios y objetivos de Docker. Por eso, si no sabe lo que es Docker, se sugiere buscar material explicativo. Si ya sabe lo que es Docker, esta gu\u00eda lo acercar\u00e1 a su uso. Por el contrario, si es un usuario de Docker, posiblemente encontrar\u00e1 poco \u00fatil esta gu\u00eda, pero cada ficha tiene material adicional al que podr\u00e1 consultar. Qu\u00e9 se puede aprender con esta gu\u00eda A usar docker. Que docker es mucho m\u00e1s que esta gu\u00eda, y que vale la pena cada minuto invertido en aprenderlo. Que docker es muy divertido.","title":"Introducci\u00f3n"},{"location":"#docker-guia-del-usuario","text":"Bienvenidos a la gu\u00eda para el usuario Docker. Su intenci\u00f3n es ser manual de referencia y gu\u00eda de aprendizaje b\u00e1sico, es decir llevar r\u00e1pidamente al uso de Docker sin demasiado \u00e9nfasis en fundamentos o explicaciones de por qu\u00e9 suceden las cosas.","title":"Docker - Gu\u00eda del Usuario"},{"location":"#como-utilizar-esta-guia","text":"Esta gu\u00eda est\u00e1 redactada en markdown y puede ser clonada a su disco para hacerle las modificaciones y mejoras que deseen. La gu\u00eda puede ser le\u00edda en forma secuencial o aleatorea, de acuerdo a las necesidades de cada uno","title":"C\u00f3mo utilizar esta gu\u00eda"},{"location":"#a-quien-va-dirigida-esta-guia","text":"Inicialmente a cualquiera que est\u00e9 interesado en Docker. No es una gu\u00eda b\u00e1sica, a pesar que empieza desde usos b\u00e1sicos de Docker, se recomienda entender los conceptos de contenedores en Linux y, obviamente, comprender los principios y objetivos de Docker. Por eso, si no sabe lo que es Docker, se sugiere buscar material explicativo. Si ya sabe lo que es Docker, esta gu\u00eda lo acercar\u00e1 a su uso. Por el contrario, si es un usuario de Docker, posiblemente encontrar\u00e1 poco \u00fatil esta gu\u00eda, pero cada ficha tiene material adicional al que podr\u00e1 consultar.","title":"A qui\u00e9n va dirigida esta gu\u00eda"},{"location":"#que-se-puede-aprender-con-esta-guia","text":"A usar docker. Que docker es mucho m\u00e1s que esta gu\u00eda, y que vale la pena cada minuto invertido en aprenderlo. Que docker es muy divertido.","title":"Qu\u00e9 se puede aprender con esta gu\u00eda"},{"location":"about/","text":"Puer muris lacrimas et sapies lugebitis medias Theseus manibus dedit Lorem markdownum fores, anno cornua spectantem delia, fuisset cortice; ponitque Cynthia. Et sorte, color movet Apolline de illis da montis demissam frigida domum; alteraque silvas mihi. Libet falsi murmur iaces perque flammasque cultus agitataque exercere quae, discedere! Genetrix diu dedit Tiresia quater debebit quoque dis intus redunco regnis adductis tenuit Mulciber . Cerebro sustinet auctor Thebae tanti auras nitor certamina munera flamma: colore per ipsos pace Athamanta. Totumque funere procul praeposito intervenit illam supplex pendent omnia cum deos. Linguam leto. Ait sunt Oliaros longus Hercule tyranni: per metues vestigia externis quaque Tyrrhena posse lacus. Dea collis ante riget in tui procul quaeque ima ore, et. Ubi manuque Stravit is remittit quippe Cythereiadasque manusque Qui domus praedae totum Adversaque currus tectum capacis exprobravit super infantemque Est numquam currere dona mihi Aegaeona sunt; dei quid, poteram partis. Audaci in sic promissa miserum, leto vero voto firmamina forte, vixque primasque motamque, nimium. Multoque pectora fertur sternitur capiat ventis illa crinem illum: et eripitur. Circumstetit cedere parias cum est meus pecorum et traxit, campis rictuque neque refugam, sit simul creatus. Habitata nigras Omnia decus moenia, abesse imago effervescere tamen . Fuit si, parce, permulcetque dato pontus Cernis Augustum agmen. Mihi sinistro : remos ense viret capiunt, mea una profuit omnia vela gentis Athis quae non opemque. Fecit cum; cruentum anguipedum voces lumina resolvit tecto: dum, dissimulat bis et est modo vocis namque inutile! Plano auxilium figitur Messapiaque aptius quos, confessis aequora sororis. Matrem attulit, pia versum tollite, nec subiecto et opem nubere est aere. Versa sistere, nota sub piget corpus anguis, idem medio, et tentoria liquida crescit, radiorum, dentes. Nate undam has solita conveniunt amore miseranda deprensa.","title":"About"},{"location":"about/#puer-muris-lacrimas-et-sapies-lugebitis-medias","text":"","title":"Puer muris lacrimas et sapies lugebitis medias"},{"location":"about/#theseus-manibus-dedit","text":"Lorem markdownum fores, anno cornua spectantem delia, fuisset cortice; ponitque Cynthia. Et sorte, color movet Apolline de illis da montis demissam frigida domum; alteraque silvas mihi. Libet falsi murmur iaces perque flammasque cultus agitataque exercere quae, discedere! Genetrix diu dedit Tiresia quater debebit quoque dis intus redunco regnis adductis tenuit Mulciber .","title":"Theseus manibus dedit"},{"location":"about/#cerebro-sustinet-auctor","text":"Thebae tanti auras nitor certamina munera flamma: colore per ipsos pace Athamanta. Totumque funere procul praeposito intervenit illam supplex pendent omnia cum deos. Linguam leto. Ait sunt Oliaros longus Hercule tyranni: per metues vestigia externis quaque Tyrrhena posse lacus. Dea collis ante riget in tui procul quaeque ima ore, et. Ubi manuque Stravit is remittit quippe Cythereiadasque manusque Qui domus praedae totum","title":"Cerebro sustinet auctor"},{"location":"about/#adversaque-currus-tectum-capacis-exprobravit-super-infantemque","text":"Est numquam currere dona mihi Aegaeona sunt; dei quid, poteram partis. Audaci in sic promissa miserum, leto vero voto firmamina forte, vixque primasque motamque, nimium. Multoque pectora fertur sternitur capiat ventis illa crinem illum: et eripitur. Circumstetit cedere parias cum est meus pecorum et traxit, campis rictuque neque refugam, sit simul creatus.","title":"Adversaque currus tectum capacis exprobravit super infantemque"},{"location":"about/#habitata-nigras","text":"Omnia decus moenia, abesse imago effervescere tamen . Fuit si, parce, permulcetque dato pontus Cernis Augustum agmen. Mihi sinistro : remos ense viret capiunt, mea una profuit omnia vela gentis Athis quae non opemque. Fecit cum; cruentum anguipedum voces lumina resolvit tecto: dum, dissimulat bis et est modo vocis namque inutile! Plano auxilium figitur Messapiaque aptius quos, confessis aequora sororis. Matrem attulit, pia versum tollite, nec subiecto et opem nubere est aere. Versa sistere, nota sub piget corpus anguis, idem medio, et tentoria liquida crescit, radiorum, dentes. Nate undam has solita conveniunt amore miseranda deprensa.","title":"Habitata nigras"},{"location":"chapter01/01funciona/","text":"C\u00f3mo funciona docker Generalidades Generalmente docker (o contenedores) se explican a trav\u00e9s de las diferencias entre virtualizaci\u00f3n y contenedores y destacando los pro y contras de cada uno de ellos. Los contenedores es un m\u00e9todo de encapsular o aislar, a nivel de kernel, procesos y recursos en el sistema operativo de forma que no tengan contacto o posibilidad de conocer otros contenedores que est\u00e1n corriendo sobre el mismo sistema operativo. Contenedores se construyen a trav\u00e9s de m\u00e9todos de aislamiento (chroot, labels, virtual networks, etc) que hacen que los comandos que se ejecuten en el contenedor (ps, top, ip, free, ls, etc.) solo tengan acceso a los recursos asignados al contenedor y no llegan a ver los del sistema operativo principal ni los de otros contenedores. Docker es una implementaci\u00f3n de las funcionalidades de contenedores para sistemas GNU/Linux que tiene como objetivo facilitar la creaci\u00f3n, uso y la posibilidad de compartir los contenedores creados, de forma que no solo se pueden levantar en un sistema, sino que pueden ejecutarse en multiples equipos e, inclusive, distribuciones de Linux. Las im\u00e1genes de docker es la forma en que se comparten los contenedores, mediante repositorios de im\u00e1genes llamados Registry a los que se accede para obtener im\u00e1genes con distinto grado de personalizaci\u00f3n que se utilizan para correr aplicaciones en distintos sistemas. Los docker en cuanto contenedores representan un est\u00e1ndar que permite compartir aplicaciones para poner a correr en distintos sistemas con un m\u00ednimo de esfuerzo de instalaci\u00f3n y ocupando los recursos que requiera la aplicaci\u00f3n, con un m\u00ednimo de sobrecarga de construcci\u00f3n o mantenimiento. De esta forma docker ha evolucionado a conceptos de m\u00e1xima aislaci\u00f3n entre procesos (Microservicios) y ejecuci\u00f3n paralela de varias instancias iguales (Cluster). Tecnolog\u00eda Docker est\u00e1 escrito en el lenguaje GO y permite configurar el kernel Linux para construir y mantener los contenedores. Namespaces Los contenedores utiliza namespaces (etiquetas) para aislar el contenedor. El ejecutar un contenedor se crea una etiqueta que identificar\u00e1: PID - Aislaci\u00f3n de procesos. NET - Aislaci\u00f3n de interfaces de red, rutas, reglas de filtrado, etc. IPC - Recursos IPC (InterProcess Communication). MNT - Puntos de montado del filesystem UTS - Aislaci\u00f3n de kernel e identificadores de versi\u00f3n (UTS: Unix Timesharing System). CGroups Los control groups permiten limitar el acceso a determinados recursos. Mediante los cgroups el kernel permitir\u00e1 compartir recursos reales a los containers y les establecer\u00e1 l\u00edmites de uso. Union filesystem El filesystem Union (UnionFS) permite crear capas de modificaciones. Docker utiliza UnionFS para optimizar los bloques y las im\u00e1genes que crean los contenedores. Container format Docker Engine combina estos elementos (namespaces, cgroups y UnionFS) para crear un entorno llamado container format . El container format por defecto se llama libcontainer , que se usa sobre sistemas GNU/Linux. En un futuro Docker puede soportar otros formatos de container que permitir\u00e1n incorporarlo a otros sistemas como BSD o Solaris. Referencias: https://docs.docker.com/engine/docker-overview/","title":"C\u00f3mo funciona docker"},{"location":"chapter01/01funciona/#como-funciona-docker","text":"","title":"C\u00f3mo funciona docker"},{"location":"chapter01/01funciona/#generalidades","text":"Generalmente docker (o contenedores) se explican a trav\u00e9s de las diferencias entre virtualizaci\u00f3n y contenedores y destacando los pro y contras de cada uno de ellos. Los contenedores es un m\u00e9todo de encapsular o aislar, a nivel de kernel, procesos y recursos en el sistema operativo de forma que no tengan contacto o posibilidad de conocer otros contenedores que est\u00e1n corriendo sobre el mismo sistema operativo. Contenedores se construyen a trav\u00e9s de m\u00e9todos de aislamiento (chroot, labels, virtual networks, etc) que hacen que los comandos que se ejecuten en el contenedor (ps, top, ip, free, ls, etc.) solo tengan acceso a los recursos asignados al contenedor y no llegan a ver los del sistema operativo principal ni los de otros contenedores. Docker es una implementaci\u00f3n de las funcionalidades de contenedores para sistemas GNU/Linux que tiene como objetivo facilitar la creaci\u00f3n, uso y la posibilidad de compartir los contenedores creados, de forma que no solo se pueden levantar en un sistema, sino que pueden ejecutarse en multiples equipos e, inclusive, distribuciones de Linux. Las im\u00e1genes de docker es la forma en que se comparten los contenedores, mediante repositorios de im\u00e1genes llamados Registry a los que se accede para obtener im\u00e1genes con distinto grado de personalizaci\u00f3n que se utilizan para correr aplicaciones en distintos sistemas. Los docker en cuanto contenedores representan un est\u00e1ndar que permite compartir aplicaciones para poner a correr en distintos sistemas con un m\u00ednimo de esfuerzo de instalaci\u00f3n y ocupando los recursos que requiera la aplicaci\u00f3n, con un m\u00ednimo de sobrecarga de construcci\u00f3n o mantenimiento. De esta forma docker ha evolucionado a conceptos de m\u00e1xima aislaci\u00f3n entre procesos (Microservicios) y ejecuci\u00f3n paralela de varias instancias iguales (Cluster).","title":"Generalidades"},{"location":"chapter01/01funciona/#tecnologia","text":"Docker est\u00e1 escrito en el lenguaje GO y permite configurar el kernel Linux para construir y mantener los contenedores.","title":"Tecnolog\u00eda"},{"location":"chapter01/01funciona/#namespaces","text":"Los contenedores utiliza namespaces (etiquetas) para aislar el contenedor. El ejecutar un contenedor se crea una etiqueta que identificar\u00e1: PID - Aislaci\u00f3n de procesos. NET - Aislaci\u00f3n de interfaces de red, rutas, reglas de filtrado, etc. IPC - Recursos IPC (InterProcess Communication). MNT - Puntos de montado del filesystem UTS - Aislaci\u00f3n de kernel e identificadores de versi\u00f3n (UTS: Unix Timesharing System).","title":"Namespaces"},{"location":"chapter01/01funciona/#cgroups","text":"Los control groups permiten limitar el acceso a determinados recursos. Mediante los cgroups el kernel permitir\u00e1 compartir recursos reales a los containers y les establecer\u00e1 l\u00edmites de uso.","title":"CGroups"},{"location":"chapter01/01funciona/#union-filesystem","text":"El filesystem Union (UnionFS) permite crear capas de modificaciones. Docker utiliza UnionFS para optimizar los bloques y las im\u00e1genes que crean los contenedores.","title":"Union filesystem"},{"location":"chapter01/01funciona/#container-format","text":"Docker Engine combina estos elementos (namespaces, cgroups y UnionFS) para crear un entorno llamado container format . El container format por defecto se llama libcontainer , que se usa sobre sistemas GNU/Linux. En un futuro Docker puede soportar otros formatos de container que permitir\u00e1n incorporarlo a otros sistemas como BSD o Solaris.","title":"Container format"},{"location":"chapter01/01funciona/#referencias","text":"https://docs.docker.com/engine/docker-overview/","title":"Referencias:"},{"location":"chapter01/02verificar/","text":"Verificaci\u00f3n de la instalaci\u00f3n No es un objetivo de esta gu\u00eda abordar la instalaci\u00f3n de docker . Si bien es un proceso sencillo, los requisitos y opciones de configuraci\u00f3n var\u00edan seg\u00fan d\u00f3nde se va a utilizar docker. Docker es nativo de sistemas operativos Linux y los procesos de instalaci\u00f3n difieren de acuerdo a la distribuci\u00f3n y versi\u00f3n de Linux que se use. Pero en la actualidad, docker se puede instalar en otros sistemas operativos como macOS y Windows . Verificaci\u00f3n de la instalaci\u00f3n Lo primero es consultar la versi\u00f3n instalada de docker: $ docker version que producir\u00e1 una salida semejante a esta: Client: Version: 18.03.1-ce API version: 1.37 Go version: go1.9.5 Git commit: 9ee9f40 Built: Thu Apr 26 07:17:20 2018 OS/Arch: linux/amd64 Experimental: false Orchestrator: swarm Server: Engine: Version: 18.03.1-ce API version: 1.37 (minimum version 1.12) Go version: go1.9.5 Git commit: 9ee9f40 Built: Thu Apr 26 07:15:30 2018 OS/Arch: linux/amd64 Experimental: false C\u00f3mo puede ver, en su equipo est\u00e1 corriendo un daemon llamado Docker Engine (Server) que ser\u00e1 encargado de ejecutar y mantener los contenedores. Por otro lado dispone de un cliente que es el comando docker propiamente dicho. Y seguidamente con el comando $ docker system info saber c\u00f3mo est\u00e1 docker funcionando en nuestro sistema (los datos mostrados pueden variar): Containers: 0 Running: 0 Paused: 0 Stopped: 0 Images: 0 Server Version: 18.03.1-ce Storage Driver: overlay2 Backing Filesystem: extfs Supports d_type: true Native Overlay Diff: true Logging Driver: json-file Cgroup Driver: cgroupfs Plugins: Volume: local Network: bridge host macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file logentries splunk syslog Swarm: inactive Runtimes: runc Default Runtime: runc Init Binary: docker-init containerd version: 773c489c9c1b21a6d78b5c538cd395416ec50f88 runc version: 4fc53a81fb7c994640722ac585fa9ca548971871 init version: 949e6fa Security Options: apparmor seccomp Profile: default Kernel Version: 4.4.0-127-generic Operating System: Ubuntu 16.04.4 LTS OSType: linux Architecture: x86_64 CPUs: 1 Total Memory: 992.2MiB Name: server ID: ILHX:XLTM:6XDZ:FUYB:DY7I:ETMT:J4BQ:7XQ6:5MPY:TD6X:7M6L:NZE7 Docker Root Dir: /var/lib/docker Debug Mode (client): false Debug Mode (server): false Registry: https://index.docker.io/v1/ Labels: Experimental: false Insecure Registries: 127.0.0.0/8 Live Restore Enabled: false","title":"Verificaci\u00f3n de la instalaci\u00f3n"},{"location":"chapter01/02verificar/#verificacion-de-la-instalacion","text":"No es un objetivo de esta gu\u00eda abordar la instalaci\u00f3n de docker . Si bien es un proceso sencillo, los requisitos y opciones de configuraci\u00f3n var\u00edan seg\u00fan d\u00f3nde se va a utilizar docker. Docker es nativo de sistemas operativos Linux y los procesos de instalaci\u00f3n difieren de acuerdo a la distribuci\u00f3n y versi\u00f3n de Linux que se use. Pero en la actualidad, docker se puede instalar en otros sistemas operativos como macOS y Windows .","title":"Verificaci\u00f3n de la instalaci\u00f3n"},{"location":"chapter01/02verificar/#verificacion-de-la-instalacion_1","text":"Lo primero es consultar la versi\u00f3n instalada de docker: $ docker version que producir\u00e1 una salida semejante a esta: Client: Version: 18.03.1-ce API version: 1.37 Go version: go1.9.5 Git commit: 9ee9f40 Built: Thu Apr 26 07:17:20 2018 OS/Arch: linux/amd64 Experimental: false Orchestrator: swarm Server: Engine: Version: 18.03.1-ce API version: 1.37 (minimum version 1.12) Go version: go1.9.5 Git commit: 9ee9f40 Built: Thu Apr 26 07:15:30 2018 OS/Arch: linux/amd64 Experimental: false C\u00f3mo puede ver, en su equipo est\u00e1 corriendo un daemon llamado Docker Engine (Server) que ser\u00e1 encargado de ejecutar y mantener los contenedores. Por otro lado dispone de un cliente que es el comando docker propiamente dicho. Y seguidamente con el comando $ docker system info saber c\u00f3mo est\u00e1 docker funcionando en nuestro sistema (los datos mostrados pueden variar): Containers: 0 Running: 0 Paused: 0 Stopped: 0 Images: 0 Server Version: 18.03.1-ce Storage Driver: overlay2 Backing Filesystem: extfs Supports d_type: true Native Overlay Diff: true Logging Driver: json-file Cgroup Driver: cgroupfs Plugins: Volume: local Network: bridge host macvlan null overlay Log: awslogs fluentd gcplogs gelf journald json-file logentries splunk syslog Swarm: inactive Runtimes: runc Default Runtime: runc Init Binary: docker-init containerd version: 773c489c9c1b21a6d78b5c538cd395416ec50f88 runc version: 4fc53a81fb7c994640722ac585fa9ca548971871 init version: 949e6fa Security Options: apparmor seccomp Profile: default Kernel Version: 4.4.0-127-generic Operating System: Ubuntu 16.04.4 LTS OSType: linux Architecture: x86_64 CPUs: 1 Total Memory: 992.2MiB Name: server ID: ILHX:XLTM:6XDZ:FUYB:DY7I:ETMT:J4BQ:7XQ6:5MPY:TD6X:7M6L:NZE7 Docker Root Dir: /var/lib/docker Debug Mode (client): false Debug Mode (server): false Registry: https://index.docker.io/v1/ Labels: Experimental: false Insecure Registries: 127.0.0.0/8 Live Restore Enabled: false","title":"Verificaci\u00f3n de la instalaci\u00f3n"},{"location":"chapter01/","text":"Generalidades de docker C\u00f3mo funciona docker Verificaci\u00f3n de la instalaci\u00f3n","title":"Generalidades de docker"},{"location":"chapter01/#generalidades-de-docker","text":"C\u00f3mo funciona docker Verificaci\u00f3n de la instalaci\u00f3n","title":"Generalidades de docker"},{"location":"chapter02/01autoejecutable/","text":"Docker autoejecutable Cuando utilizamos docker para correr una imagen que ya tiene un proceso configurado decimos que ejecutamos un proceso docketizado . $ docker container run hello-world Al ejecutar buscar\u00e1 localmente una imagen llamada hello-world , no la encontrar\u00e1 proceder\u00e1 a descargarla y guardarla en el registry local: Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 9bb5a5d4561a: Pull complete Digest: sha256:f5233545e43561214ca4891fd1157e1c3c563316ed8e237750d59bde73361e77 Status: Downloaded newer image for hello-world:latest Seguidamente correr\u00e1 el proceso que posee la imagen y producir\u00e1 la siguiente salida: Hello from Docker. This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker Hub account: https://hub.docker.com For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ Esta imagen ha sido creada con el \u00fanico fin de correr ese proceso docketizado que exclusivamente muestra ese texto. Ejercicios 1. Vuelva a ejecutar la imagen hello-world y preste atenci\u00f3n a que ahora no ser\u00e1 descargada, sino que se levantar\u00e1 directamente desde el repositorio local 2. Liste las im\u00e1genes con el comando docker image ls Preste atenci\u00f3n al tama\u00f1o que ocupa en el disco Referencias: https://hub.docker.com/_/hello-world/","title":"Docker autoejecutable"},{"location":"chapter02/01autoejecutable/#docker-autoejecutable","text":"Cuando utilizamos docker para correr una imagen que ya tiene un proceso configurado decimos que ejecutamos un proceso docketizado . $ docker container run hello-world Al ejecutar buscar\u00e1 localmente una imagen llamada hello-world , no la encontrar\u00e1 proceder\u00e1 a descargarla y guardarla en el registry local: Unable to find image 'hello-world:latest' locally latest: Pulling from library/hello-world 9bb5a5d4561a: Pull complete Digest: sha256:f5233545e43561214ca4891fd1157e1c3c563316ed8e237750d59bde73361e77 Status: Downloaded newer image for hello-world:latest Seguidamente correr\u00e1 el proceso que posee la imagen y producir\u00e1 la siguiente salida: Hello from Docker. This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps: 1. The Docker client contacted the Docker daemon. 2. The Docker daemon pulled the \"hello-world\" image from the Docker Hub. 3. The Docker daemon created a new container from that image which runs the executable that produces the output you are currently reading. 4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal. To try something more ambitious, you can run an Ubuntu container with: $ docker run -it ubuntu bash Share images, automate workflows, and more with a free Docker Hub account: https://hub.docker.com For more examples and ideas, visit: https://docs.docker.com/engine/userguide/ Esta imagen ha sido creada con el \u00fanico fin de correr ese proceso docketizado que exclusivamente muestra ese texto.","title":"Docker autoejecutable"},{"location":"chapter02/01autoejecutable/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter02/01autoejecutable/#1","text":"Vuelva a ejecutar la imagen hello-world y preste atenci\u00f3n a que ahora no ser\u00e1 descargada, sino que se levantar\u00e1 directamente desde el repositorio local","title":"1."},{"location":"chapter02/01autoejecutable/#2","text":"Liste las im\u00e1genes con el comando docker image ls Preste atenci\u00f3n al tama\u00f1o que ocupa en el disco","title":"2."},{"location":"chapter02/01autoejecutable/#referencias","text":"https://hub.docker.com/_/hello-world/","title":"Referencias:"},{"location":"chapter02/02comando/","text":"Docker como comando Tambi\u00e9n podemos tomar una imagen cualquiera, aunque tenga una aplicaci\u00f3n instalada y ejecutar comandos en ella: $ docker container run busybox echo 'hola mundo!' La primera vez que lo ejecutamos, descargar\u00e1 la imagen busybox e inmediatamente ejecutar\u00e1 el comando echo 'hola mundo!' produciendo la salida correspondiente: Unable to find image 'busybox:latest' locally latest: Pulling from busybox 920777304d1d: Pull complete 437595becdeb: Pull complete Digest: sha256:4a731fb46adc5cefe3ae374a8b6020fce9 Status: Downloaded newer image for busybox:latest hola mundo! A partir de tener la imagen busybox local, podemos ejecutar otros comandos con ella: $ docker container run busybox ps xa PID USER TIME COMMAND 1 root 0:00 ps xa Para saber por qu\u00e9 tenemos un \u00fanico proceso con PID 1 , ver C\u00f3mo funciona docker Cada vez que ejecutamos una imagen , queda guardado el contenedor ejecutado, es decir no se borra: $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d223748120dc busybox \"echo 'hola mundo!'\" 17 seconds ago Exited (0) 16 seconds ago mystifying_heyrovsky 4018dd3cdd71 hello-world \"/hello\" 21 minutes ago Exited (0) 21 minutes ago vigorous_shannon Ejercicios 1. Ejecute los siguientes comandos con imagen alpine : ls -l cat /etc/alpine-release ps axu 2. Compare la salida del comando mount ejecutado en el sistema GNU/Linux y dentro de un contenedor (por ej. con la imagen alpine ). Note la diferencia del directorio / montado en el contenedor y en el sistema externo . 3. Encuentre la diferencia entre ejecutar el comando man en las im\u00e1genes de alpine y busybox .","title":"Docker como comando"},{"location":"chapter02/02comando/#docker-como-comando","text":"Tambi\u00e9n podemos tomar una imagen cualquiera, aunque tenga una aplicaci\u00f3n instalada y ejecutar comandos en ella: $ docker container run busybox echo 'hola mundo!' La primera vez que lo ejecutamos, descargar\u00e1 la imagen busybox e inmediatamente ejecutar\u00e1 el comando echo 'hola mundo!' produciendo la salida correspondiente: Unable to find image 'busybox:latest' locally latest: Pulling from busybox 920777304d1d: Pull complete 437595becdeb: Pull complete Digest: sha256:4a731fb46adc5cefe3ae374a8b6020fce9 Status: Downloaded newer image for busybox:latest hola mundo! A partir de tener la imagen busybox local, podemos ejecutar otros comandos con ella: $ docker container run busybox ps xa PID USER TIME COMMAND 1 root 0:00 ps xa Para saber por qu\u00e9 tenemos un \u00fanico proceso con PID 1 , ver C\u00f3mo funciona docker Cada vez que ejecutamos una imagen , queda guardado el contenedor ejecutado, es decir no se borra: $ docker container ls -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES d223748120dc busybox \"echo 'hola mundo!'\" 17 seconds ago Exited (0) 16 seconds ago mystifying_heyrovsky 4018dd3cdd71 hello-world \"/hello\" 21 minutes ago Exited (0) 21 minutes ago vigorous_shannon","title":"Docker como comando"},{"location":"chapter02/02comando/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter02/02comando/#1","text":"Ejecute los siguientes comandos con imagen alpine : ls -l cat /etc/alpine-release ps axu","title":"1."},{"location":"chapter02/02comando/#2","text":"Compare la salida del comando mount ejecutado en el sistema GNU/Linux y dentro de un contenedor (por ej. con la imagen alpine ). Note la diferencia del directorio / montado en el contenedor y en el sistema externo .","title":"2."},{"location":"chapter02/02comando/#3","text":"Encuentre la diferencia entre ejecutar el comando man en las im\u00e1genes de alpine y busybox .","title":"3."},{"location":"chapter02/03shell/","text":"Docker como shell Podemos ingresar al contenedor docker para ejecutar los comandos que est\u00e9n disponibles en la imagen que utilizamos para correrlo. $ docker run -it debian bash donde: -i crea una sesi\u00f3n interactiva -t ofrece una terminal (tty) y la imagen que utilizar\u00e1 es un debian m\u00ednimo y ejecutar\u00e1 el comando bash , dando como resultado un shell: root@ce1a1c7bf990:/# root@ce1a1c7bf990:/# pwd / root@ce1a1c7bf990:/# ps ax PID TTY STAT TIME COMMAND 1 ? Ss 0:00 bash 6 ? R+ 0:00 ps ax root@ce1a1c7bf990:/# exit exit Ejercicios 1. Utilizamos la funcionalidad interactiva para verificar la aislaci\u00f3n entre contenedores, ejecute los siguientes comandos: docker container run -it alpine /bin/ash echo \"hello world\" > hello.txt ls exit Ejecutamos otro container y listamos su contenido docker container run alpine ls Busque el container que ha ejecutado con /bin/ash docker container ls -a | grep ash e in\u00edcielo nuevamente docker container start <container ID> en el container que acaba de iniciar ejecute un comando con la opci\u00f3n exec docker container exec <container ID> ls 2. Del ejercicio anterior entienda bien al diferencia entre las opciones exec y run","title":"Docker como shell"},{"location":"chapter02/03shell/#docker-como-shell","text":"Podemos ingresar al contenedor docker para ejecutar los comandos que est\u00e9n disponibles en la imagen que utilizamos para correrlo. $ docker run -it debian bash donde: -i crea una sesi\u00f3n interactiva -t ofrece una terminal (tty) y la imagen que utilizar\u00e1 es un debian m\u00ednimo y ejecutar\u00e1 el comando bash , dando como resultado un shell: root@ce1a1c7bf990:/# root@ce1a1c7bf990:/# pwd / root@ce1a1c7bf990:/# ps ax PID TTY STAT TIME COMMAND 1 ? Ss 0:00 bash 6 ? R+ 0:00 ps ax root@ce1a1c7bf990:/# exit exit","title":"Docker como shell"},{"location":"chapter02/03shell/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter02/03shell/#1","text":"Utilizamos la funcionalidad interactiva para verificar la aislaci\u00f3n entre contenedores, ejecute los siguientes comandos: docker container run -it alpine /bin/ash echo \"hello world\" > hello.txt ls exit Ejecutamos otro container y listamos su contenido docker container run alpine ls Busque el container que ha ejecutado con /bin/ash docker container ls -a | grep ash e in\u00edcielo nuevamente docker container start <container ID> en el container que acaba de iniciar ejecute un comando con la opci\u00f3n exec docker container exec <container ID> ls","title":"1."},{"location":"chapter02/03shell/#2","text":"Del ejercicio anterior entienda bien al diferencia entre las opciones exec y run","title":"2."},{"location":"chapter02/04servicio/","text":"Docker como servicio Poner a correr una imagen docker cuyo proceso es un servicio supone dejar corriendo algo en forma permanente para utilizar el servicio. Al poner algo a correr en forma permanente debemos, adem\u00e1s de saber c\u00f3mo ejecutarlo, saber si est\u00e1 funcionando, utilizar el servicio y c\u00f3mo apagarlo, as\u00ed que este paso involucra algunos conceptos m\u00e1s del uso de docker. Ejecuci\u00f3n Entonces, ejecutando: $ docker run -d -p 8082:8082 andygrunwald/simple-webserver donde: -d pondr\u00e1 a correr el docker en //background// -p 8082:8082 abrir\u00e1 el puerto 8082 en el equipo local conectar\u00e1 con el puerto 8082 del contenedor. y descargar\u00e1 la imagen y nos devolver\u00e1 el prompt , pero ha dejado corriendo el docker. Saber si est\u00e1 funcionando Podemos interrogar con docker si el contenedor est\u00e1 corriendo: $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8d5297a02f2c andygrunwald/simple-webserver \"app\" About a minute ago Up About a minute 0.0.0.0:8082->8082/tcp stupefied_bohr Utilizar el servicio El servicio es un servidor web simple que lo podemos ver con el navegador conectando al puerto local, que configuramos con -p , mediante el comando curl : $ curl http://localhost:8082/version simple webserver v1.0.0 Apagar el contenedor Como al contenedor lo creamos sin nombre, nos referimos a \u00e9l por el Container ID y lo apagamos con: $ docker container stop 01a420094251 $ docker container ls CONTAINER ID IMAGE COMMAND $ Encender el contenedor $ docker container start 01a420094251 Acceder a un contenedor en ejecuci\u00f3n Es posible acceder a un contenedor, para modificar contenido, revisar logs, verificar distintas configuraciones, obteniendo shell: docker container exec -it eager_hopper sh donde: -i entrar\u00e1 en modo interactivo -t asignara una consola tty al proceso ejecutado (sh) Ejercicios 1. Borrar todos los container apagados utilizando los comandos: docker container ps -a docker container rm <CONTAINER-ID> 2. Volver a ejecutar el container ( Ejecuci\u00f3n )como se muestra a principio esta secci\u00f3n verificando que est\u00e9 activo y tratar de borrarlo con los comandos, verificando las diferencias entre ellos: docker container rm <CONTAINER-ID> docker container rm -f <CONTAINER-ID> 3. Volver a ejecutar el container ( Ejecuci\u00f3n ) pero esta vez sin el par\u00e1metro -d dejando el servicio en primer plano. Desde otra consola hacer conexiones con curl http://localhost:8082 Salir con Ctrl-C y verificar qu\u00e9 sucede con el contenedor utilizando el comando docker container ls Referencias: https://hub.docker.com/r/andygrunwald/simple-webserver/","title":"Docker como servicio"},{"location":"chapter02/04servicio/#docker-como-servicio","text":"Poner a correr una imagen docker cuyo proceso es un servicio supone dejar corriendo algo en forma permanente para utilizar el servicio. Al poner algo a correr en forma permanente debemos, adem\u00e1s de saber c\u00f3mo ejecutarlo, saber si est\u00e1 funcionando, utilizar el servicio y c\u00f3mo apagarlo, as\u00ed que este paso involucra algunos conceptos m\u00e1s del uso de docker.","title":"Docker como servicio"},{"location":"chapter02/04servicio/#ejecucion","text":"Entonces, ejecutando: $ docker run -d -p 8082:8082 andygrunwald/simple-webserver donde: -d pondr\u00e1 a correr el docker en //background// -p 8082:8082 abrir\u00e1 el puerto 8082 en el equipo local conectar\u00e1 con el puerto 8082 del contenedor. y descargar\u00e1 la imagen y nos devolver\u00e1 el prompt , pero ha dejado corriendo el docker.","title":"Ejecuci\u00f3n"},{"location":"chapter02/04servicio/#saber-si-esta-funcionando","text":"Podemos interrogar con docker si el contenedor est\u00e1 corriendo: $ docker container ls CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8d5297a02f2c andygrunwald/simple-webserver \"app\" About a minute ago Up About a minute 0.0.0.0:8082->8082/tcp stupefied_bohr","title":"Saber si est\u00e1 funcionando"},{"location":"chapter02/04servicio/#utilizar-el-servicio","text":"El servicio es un servidor web simple que lo podemos ver con el navegador conectando al puerto local, que configuramos con -p , mediante el comando curl : $ curl http://localhost:8082/version simple webserver v1.0.0","title":"Utilizar el servicio"},{"location":"chapter02/04servicio/#apagar-el-contenedor","text":"Como al contenedor lo creamos sin nombre, nos referimos a \u00e9l por el Container ID y lo apagamos con: $ docker container stop 01a420094251 $ docker container ls CONTAINER ID IMAGE COMMAND $","title":"Apagar el contenedor"},{"location":"chapter02/04servicio/#encender-el-contenedor","text":"$ docker container start 01a420094251","title":"Encender el contenedor"},{"location":"chapter02/04servicio/#acceder-a-un-contenedor-en-ejecucion","text":"Es posible acceder a un contenedor, para modificar contenido, revisar logs, verificar distintas configuraciones, obteniendo shell: docker container exec -it eager_hopper sh donde: -i entrar\u00e1 en modo interactivo -t asignara una consola tty al proceso ejecutado (sh)","title":"Acceder a un contenedor en ejecuci\u00f3n"},{"location":"chapter02/04servicio/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter02/04servicio/#1","text":"Borrar todos los container apagados utilizando los comandos: docker container ps -a docker container rm <CONTAINER-ID>","title":"1."},{"location":"chapter02/04servicio/#2","text":"Volver a ejecutar el container ( Ejecuci\u00f3n )como se muestra a principio esta secci\u00f3n verificando que est\u00e9 activo y tratar de borrarlo con los comandos, verificando las diferencias entre ellos: docker container rm <CONTAINER-ID> docker container rm -f <CONTAINER-ID>","title":"2."},{"location":"chapter02/04servicio/#3","text":"Volver a ejecutar el container ( Ejecuci\u00f3n ) pero esta vez sin el par\u00e1metro -d dejando el servicio en primer plano. Desde otra consola hacer conexiones con curl http://localhost:8082 Salir con Ctrl-C y verificar qu\u00e9 sucede con el contenedor utilizando el comando docker container ls","title":"3."},{"location":"chapter02/04servicio/#referencias","text":"https://hub.docker.com/r/andygrunwald/simple-webserver/","title":"Referencias:"},{"location":"chapter02/","text":"Primeros pasos Estos ejemplos de primeros pasos pretenden mostrar r\u00e1pidamente acciones b\u00e1sicas que se suelen realizar con docker y, a la vez, dar una primer impresi\u00f3n de su potencia para la ejecuci\u00f3n de aplicaciones. Puede verificar las opciones disponibles con el comando docker sin ning\u00fan par\u00e1metro ni argumento: Usage: docker COMMAND Management Commands: config Manage Docker configs container Manage containers image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumes El comando container es la opci\u00f3n por defecto del comando docker, por lo que generalmente no se escribe, utilizando directamente los sub-comandos. Ejercicios 1. Revise con el comando ps los procesos docker que est\u00e1n corriendo en su equipo. 2. Revise los paquetes que est\u00e1n instalados vinculados a docker en su sistema 3. Liste el status y reinicie el daemon correspondiente a los servicios de Docker Engine. 4. Localice con el comando whereis d\u00f3nde se encuentra el ejecutable docker","title":"Primeros pasos"},{"location":"chapter02/#primeros-pasos","text":"Estos ejemplos de primeros pasos pretenden mostrar r\u00e1pidamente acciones b\u00e1sicas que se suelen realizar con docker y, a la vez, dar una primer impresi\u00f3n de su potencia para la ejecuci\u00f3n de aplicaciones. Puede verificar las opciones disponibles con el comando docker sin ning\u00fan par\u00e1metro ni argumento: Usage: docker COMMAND Management Commands: config Manage Docker configs container Manage containers image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services swarm Manage Swarm system Manage Docker trust Manage trust on Docker images volume Manage volumes El comando container es la opci\u00f3n por defecto del comando docker, por lo que generalmente no se escribe, utilizando directamente los sub-comandos.","title":"Primeros pasos"},{"location":"chapter02/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter02/#1","text":"Revise con el comando ps los procesos docker que est\u00e1n corriendo en su equipo.","title":"1."},{"location":"chapter02/#2","text":"Revise los paquetes que est\u00e1n instalados vinculados a docker en su sistema","title":"2."},{"location":"chapter02/#3","text":"Liste el status y reinicie el daemon correspondiente a los servicios de Docker Engine.","title":"3."},{"location":"chapter02/#4","text":"Localice con el comando whereis d\u00f3nde se encuentra el ejecutable docker","title":"4."},{"location":"chapter03/01imagenes/","text":"Gesti\u00f3n de im\u00e1genes Buscar El repositorio de im\u00e1genes p\u00fablico Docker Hub se puede buscar mediante web o con el comando search : docker search ubuntu | head desplegar\u00e1 la totalidad de las im\u00e1genes que posean ubuntu en su nombre o descripci\u00f3n. Para obtener las im\u00e1genes oficiales podemos filtrar solo las im\u00e1genes que comienzan con ubuntu: docker search ubuntu | grep ^ubuntu tags Podemos contular por el tag de la imagen, directamente invocando al api del registry que nos devolver\u00e1 un JSON que podemos filtrar con el comando jq : curl -s -S 'https://registry.hub.docker.com/v2/repositories/library/ubuntu/tags/' | jq '.\"results\"[][\"name\"]' |sort Descargar La forma de descargar una imagen para incorporarla al repositorio local es con el comando pull : docker pull ubuntu:bionic Debemos recordar que la opci\u00f3n run adem\u00e1s de ejecutar una imagen docker, tambi\u00e9n la descarga y la deja en el repositorio. Gestionar El comando tag permite poner el nombre que queremos a una imagen en el formato repositorio:etiqueta docker tag ubuntu:bionic pruebas:locales Que generar\u00e1 una nueva entrada en el repositorio local con el nombre que deseamos: REPOSITORY TAG IMAGE ID CREATED SIZE pruebas locales 452a96d81c30 5 weeks ago 79.6MB ubuntu bionic 452a96d81c30 5 weeks ago 79.6MB En el repositorio local podemos hacer b\u00fasqueda de im\u00e1genes con diferentes filtros: docker images ubuntu:* Y el comando docker images posee la opci\u00f3n --filter que permite buscar im\u00e1genes por distintas caracter\u00edsticas -f, --filter valor Filtrado de la salida basado en condiciones - dangling=(true|false) - label=<key> o label=<key>=<value> - before=(<image-name>[:tag]|<image-id>|<image@digest>) - since=(<image-name>[:tag]|<image-id>|<image@digest>) - reference=(pattern of an image reference) Por ejemplo: docker images --filter \"dangling=true\" Borrar Para borrar im\u00e1genes del repositorio local se utiliza el comando rmi : docker image rmi pruebas:locales Para borrar todas las im\u00e1genes que no tienen asignado un nombre se utiliza: docker image prune Ejercicios 1. Descargar la imagen de ubuntu correspondiente a xenial Referencias: Docker Hub docker image filtering","title":"Gesti\u00f3n de im\u00e1genes"},{"location":"chapter03/01imagenes/#gestion-de-imagenes","text":"","title":"Gesti\u00f3n de im\u00e1genes"},{"location":"chapter03/01imagenes/#buscar","text":"El repositorio de im\u00e1genes p\u00fablico Docker Hub se puede buscar mediante web o con el comando search : docker search ubuntu | head desplegar\u00e1 la totalidad de las im\u00e1genes que posean ubuntu en su nombre o descripci\u00f3n. Para obtener las im\u00e1genes oficiales podemos filtrar solo las im\u00e1genes que comienzan con ubuntu: docker search ubuntu | grep ^ubuntu","title":"Buscar"},{"location":"chapter03/01imagenes/#tags","text":"Podemos contular por el tag de la imagen, directamente invocando al api del registry que nos devolver\u00e1 un JSON que podemos filtrar con el comando jq : curl -s -S 'https://registry.hub.docker.com/v2/repositories/library/ubuntu/tags/' | jq '.\"results\"[][\"name\"]' |sort","title":"tags"},{"location":"chapter03/01imagenes/#descargar","text":"La forma de descargar una imagen para incorporarla al repositorio local es con el comando pull : docker pull ubuntu:bionic Debemos recordar que la opci\u00f3n run adem\u00e1s de ejecutar una imagen docker, tambi\u00e9n la descarga y la deja en el repositorio.","title":"Descargar"},{"location":"chapter03/01imagenes/#gestionar","text":"El comando tag permite poner el nombre que queremos a una imagen en el formato repositorio:etiqueta docker tag ubuntu:bionic pruebas:locales Que generar\u00e1 una nueva entrada en el repositorio local con el nombre que deseamos: REPOSITORY TAG IMAGE ID CREATED SIZE pruebas locales 452a96d81c30 5 weeks ago 79.6MB ubuntu bionic 452a96d81c30 5 weeks ago 79.6MB En el repositorio local podemos hacer b\u00fasqueda de im\u00e1genes con diferentes filtros: docker images ubuntu:* Y el comando docker images posee la opci\u00f3n --filter que permite buscar im\u00e1genes por distintas caracter\u00edsticas -f, --filter valor Filtrado de la salida basado en condiciones - dangling=(true|false) - label=<key> o label=<key>=<value> - before=(<image-name>[:tag]|<image-id>|<image@digest>) - since=(<image-name>[:tag]|<image-id>|<image@digest>) - reference=(pattern of an image reference) Por ejemplo: docker images --filter \"dangling=true\"","title":"Gestionar"},{"location":"chapter03/01imagenes/#borrar","text":"Para borrar im\u00e1genes del repositorio local se utiliza el comando rmi : docker image rmi pruebas:locales Para borrar todas las im\u00e1genes que no tienen asignado un nombre se utiliza: docker image prune","title":"Borrar"},{"location":"chapter03/01imagenes/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter03/01imagenes/#1","text":"Descargar la imagen de ubuntu correspondiente a xenial","title":"1."},{"location":"chapter03/01imagenes/#referencias","text":"Docker Hub docker image filtering","title":"Referencias:"},{"location":"chapter03/02crear/","text":"Crear im\u00e1genes propias Existen dos m\u00e9todos para crear im\u00e1genes propias: Hacer cambios en un contenedor y exportarlo como imagen al repositorio local Generar un archivo Dockerfile con el script para generaci\u00f3n de una imagen.","title":"Crear im\u00e1genes propias"},{"location":"chapter03/02crear/#crear-imagenes-propias","text":"Existen dos m\u00e9todos para crear im\u00e1genes propias: Hacer cambios en un contenedor y exportarlo como imagen al repositorio local Generar un archivo Dockerfile con el script para generaci\u00f3n de una imagen.","title":"Crear im\u00e1genes propias"},{"location":"chapter03/03crear-contenedor/","text":"Crear a partir de un contenedor Correr una contenedor basado en la imagen debian e ingresar al shell para hacer cambios: docker container run -ti debian bash Ejecutar estos comandos para instalar figlet y salir apt-get update apt-get install -y fidlet figlet 'hello docker' exit El container est\u00e1 detenido y a partir de \u00e9l se puede crear una imagen, que se guarda en el repositorio local, con el comando container commit docker container ls -a docker container commit <CONTAINER-ID> docker image ls Le colocamos el nombre a la imagen generada con el comando image tag pues no lo hicimos junto con el container commit docker image tag <IMAGE-ID> confidget docker image ls Ahora que disponemos de una imagen basada en debian que tiene el comando figlet instalado la podemos utilizar: docker container run configlet figlet hola Ejercicios 1. 2.","title":"Crear a partir de un contenedor"},{"location":"chapter03/03crear-contenedor/#crear-a-partir-de-un-contenedor","text":"Correr una contenedor basado en la imagen debian e ingresar al shell para hacer cambios: docker container run -ti debian bash Ejecutar estos comandos para instalar figlet y salir apt-get update apt-get install -y fidlet figlet 'hello docker' exit El container est\u00e1 detenido y a partir de \u00e9l se puede crear una imagen, que se guarda en el repositorio local, con el comando container commit docker container ls -a docker container commit <CONTAINER-ID> docker image ls Le colocamos el nombre a la imagen generada con el comando image tag pues no lo hicimos junto con el container commit docker image tag <IMAGE-ID> confidget docker image ls Ahora que disponemos de una imagen basada en debian que tiene el comando figlet instalado la podemos utilizar: docker container run configlet figlet hola","title":"Crear a partir de un contenedor"},{"location":"chapter03/03crear-contenedor/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter03/03crear-contenedor/#1","text":"","title":"1."},{"location":"chapter03/03crear-contenedor/#2","text":"","title":"2."},{"location":"chapter03/04crear-dockerfile/","text":"Crear usando Dockerfile Give a sysadmin an image and their app will be up-to-date for a day, give a sysadmin a Dockerfile and their app will always be up-to-date Dockerfile es un archivo de texto que contiene un conjunto de instrucciones o comandos para la creaci\u00f3n de una imagen docker. Llamando a la funci\u00f3n docker build se leen las instrucciones del Dockerfile y se construye una imagen que se guardar\u00e1 en el repositorio local. Uso de Dockerfile Para la construcci\u00f3n de una imagen se utiliza el comando docker build ${CONTEXT} . El ${CONTEXT} son todos los archivos que necesita el Dockerfile para construir la imagen; puede ser una carpeta de nuestra propia m\u00e1quina o una URL de un repositorio git. El proceso de build lo ejecuta Docker Daemon y no el utilitario docker. Todo el ${CONTEXT} es enviado repulsivamente al docker daemon, por lo que no es recomendable utilizar un path con demasiados archivos, ya que todos ser\u00e1n enviados. El archivo Dockerfile debe estar localizado en el ra\u00edz del ${CONTEXT} Tambi\u00e9n se puede utilizar un archivo .dockerignore para especificar los archivos y carpetas que deben ser excluidos del proceso de construcci\u00f3n de la imagen y que no ser\u00e1n enviados al docker daemon, lo que mejorar\u00e1 la performance del proceso de build . Build El Dockerfile siempre parte de una imagen creada, mediante la instrucci\u00f3n FROM . FROM node:latest Con esta sola instrucci\u00f3n ya podemos crear una imagen, utilizando como ${CONTEXT} el directorio actual: $ docker build . Sending build context to Docker daemon 2.048 kB Step 1 : FROM node:latest ---> 36dc1bb7a52b Successfully built 36dc1bb7a52b Es posible indicar la ubicaci\u00f3n del Dockerfile con el argumento -f : docker build -f image/Dockerfile image/ Tambi\u00e9n podemos ponerle nombre o etiquetar la imagen a la vez que la construimos utilizando el argumento -t y el nombre que le daremos, en el formato -t ${tag}:${version} : $ docker build -t pilasguru/nodejs . $ docker build -t pilasguru/nodejs:0.0.1 . Una vez constru\u00edda podemos revisar que la imagen est\u00e9 en nuestro repositorio $ docker images pilasguru/nodejs REPOSITORY TAG IMAGE ID CREATED SIZE Pilasguru/nodejs 0.0.1 38dc1bb7a34c 2 weeks ago 655.5 MB Pilasguru/nodejs latest 38dc1bb7a34c 2 weeks ago 655.5 MB Estructura del Dockerfile El formato del archivo Dockerfile es: # Comentario INSTRUCCION argument1 argumento2 argumento3 ... La INSTRUCCION no es case-sensitive pero por costumbre se suele usar en may\u00fascula. El orden de las instrucciones es importante ya que debe seguir el orden del proceso de construcci\u00f3n de la imagen. Estructura del .dockerignore El archivo .dockerignore tiene un formato como el archivo .gitignore y es un listado por rengl\u00f3n de los archivos o carpetas que son ignorados: # comentario */temp* */*/temp* temp? testing/ .git/ Los asteriscos se utilizan como comodines e incluyen tanto archivos, carpetas y en ese caso las sub-carpetas. Instrucciones del Dockerfile FROM Un Dockerfile v\u00e1lido debe tener este instrucci\u00f3n como su primer instrucci\u00f3n e indica la imagen que se utilizar\u00e1 para construir la nueva imagen. Docker daemon primero verificar\u00e1 si la imagen existe localmente, si no proceder\u00e1 a descargarla de docker hub. Se puede utilizar de tres formas: FROM <imagen> FROM <imagen:tag> FROM <imagen>@<digest> FROM debe ser la primer l\u00ednea no comentada en el Dockerfile. Se puede utilizar m\u00faltiples veces en el mismo Dockerfile. Tanto el tag como digest son opcionales y permiten tratar de obtener la imagen exacta, pero de no estar disponible se usar\u00e1 la \u00faltima ( latest ) MAINTAINER Permite indicar el autor de la imagen y se utiliza asi: MAINTAINER <nombre> RUN Permite indicar comandos que ser\u00e1n ejecutados en una nueva capa sobre la imagen (del FROM) en el proceso de construcci\u00f3n y ese resultado ser\u00e1 guardado para pasarlo, opcionalmente, a un siguiente RUN que volver\u00e1 a crear una nueva capa. RUN tiene dos formatos: shell o exec : RUN <comando> es el formato shell. El comando se ejecutar\u00e1 en un shell que por defecto es /bin/sh -c de Linux o cmd /S /C de Windows. RUN [\u201cejecutable\u201d, \u201cargumento1\u201d, \u201cargumento2\u201d, \u201cargumento3\u201d \u2026] Un ejemplo de Dockerfile hasta ahora, quedar\u00eda construido de la siguiente forma: # Ejemplo # ---------- FROM node:latest MAINTAINER pilasguru RUN /bin/sh -c 'echo \"*** hello Dockerfile!! ***\"' RUN [\"npm\", \"--version\"] Creando una imagen con este ejemplo, tendremos la siguiente salida: \u279c docker build -t pilasguru/nodejs:0.0.3 . \u2026 Step 3 : RUN /bin/sh -c 'echo \"*** hello Dockerfile!! ***\"' ---> Running in 6ebfa85f7683 *** hello Dockerfile!! *** \u2026 Step 4 : RUN npm --version ---> Running in fc9dab7cf8c2 3.10.10 \u2026 LABEL Esta instrucci\u00f3n incluye metadatos a la imagen en el formato de pares llave-valor: LABEL <llave>=<valor> <llave>=<valor> <llae>=<valor> ... Y se pueden utilizar m\u00faltiples l\u00edneas de LABEL: LABEL \"com.ejemplo.imagen\"=\"Node JS imagen LABEL ejemplo\" LABEL version=\"0.0.4\" LABEL descripcion=\"valores pueden ser \\ separados en varias l\u00edneas\" Y por supuesto que se pueden indicar varios pares de llaves=valor en la misma instrucci\u00f3n LABEL. Veamos la construcci\u00f3n de una imagen y sus metadatos: $ docker build -t pilasguru/nodejs:0.0.3 . --no-cache=true $ docker inspect pilasguru/nodejs:0.0.3 \u2026 \"Labels\": { \"com.ejemplo.imagen\": \"Node JS image LABEL ejemplo\", \"descripcion\": \"valores pueden ser Separados en varias l\u00edneas\", \"version\": \"0.0.4\" } \u2026 EXPOSE Esta instrucci\u00f3n informa a Docker que el contenedor escuchar\u00e1 en un determinado puerto cuando est\u00e9 corriendo. EXPOSE <port> [<port>...] No significa que el puerto ser\u00e1 accesible desde el host. Para construir la red, se debe utilizar el argumento -p que publicar\u00e1 el punto al correr docker. ENV Permite configurar variables de entorno en el contenedor cuando est\u00e9 corriendo. ENV mysql_password passw0rd ENV src_folder ./src/app Se pueden consultar las declaraciones de ENV con el comando inspect : $ docker inspect linoxide/nodejs:0.0.3 \u2026 \"Env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"NPM_CONFIG_LOGLEVEL=info\", \"NODE_VERSION=7.2.1\", \"mysql_password=passw0rd\", \"src_folder=./src/app\" ] \u2026 ADD La instrucci\u00f3n ADD copia nuevos archivos, directorios o archivos remotos (desde una URL) desde un <src> y los agrega a la imagen en el lugar indicado en <dest> . Ejemplos: ADD . /app/ ADD [ \"dir con espacios/\" \"/app/\" ] En los dos ejemplos de arriba se copian los archivos de los directorios indicados en la carpeta /app/ dentro de la imagen. Si el <dest> no finaliza barra al final, se considera un archivo y en el se escribir\u00e1 el contenido de <src> . Si <dest> no existe, ser\u00e1 creado. Se permite el uso de asteriscos en <src> como ser arch* o readm?.txt . Si el origen <src> es un compactado (tar, gzip, bzip2 o xz) la ejecuci\u00f3n de ADD lo descompactar\u00e1 dentro de <dest> . COPY COPY es muy similar a ADD: hace lo mismo y tiene el mismo formato. La diferencia es que COPY no acepta URLs como <src> y en caso de ser un archivo compactado, no lo descompactar\u00e1 al copiarlo dentro de la imagen. ENTRYPOINT Este comando permite especificar un comando que ser\u00e1 siempre ejecutado cada vez que se inicie el container. ENTRYPOINT [\"/bin/echo\", \"Hola pilasguru\"] $ docker build -t pilasguru/nodejs:0.0.3 . --no-cache=true $ docker run -it --name minodejs pilasguru/nodejs:0.0.3 Hola pilasguru Tenga en cuenta que solamente un ENTRYPOINT es permitido en el Dockerfile. CMD Al igual que ENTRYPOINT permite especificar comandos a ejecutar cuando se inicie el container y tambi\u00e9n, solamente un CMD es permitido en el Dockerfile. La caracter\u00edstica de CMD es que ser\u00e1 omitido en caso de que el contenedor se inicie especificando otro comando. Si un Dockerfile especifica: ENTRYPOINT [\"/bin/echo\", \"Hola pilasguru\"] CMD [\"/bin/echo\" \"Hola Mundo!!\"] Y constru\u00edmos la imagen: $ docker build -t pilasguru/nodejs:0.0.3 . --no-cache=true Y ejecutamos: $ docker run -it --name minodejs pilasguru/nodejs:0.0.3 Hola pilasguru Hola Mundo!! Ahora si creamos un segundo comando, pero indicando un comando: $ docker run -it --name minodejs pilasguru/nodejs:0.0.3 echo \"Que onda!\" Hola pilasguru Que onda! VOLUME La instrucci\u00f3n VOLUME creara un punto de montado con el nombre especificado y tendr\u00e1 el filesystem externo al contenedor VOLUME /var/log USER La instrucci\u00f3n USER seguido del nombre o UID indica bajo que usuario correr\u00e1n las instrucciones RUN, CMD o ENTRYPOINT. WORKDIR WORKDIR permite indicar el directorio en el cual los comandos de RUN, CMD, ENTRYPOINT, COPY y ADD ser\u00e1n ejecutados. Si el directorio WORKDIR no existe, ser\u00e1 creado. WORKDIR puede ser visto como el home del contenedor Ejemplos de Dockerfile Please see the comments in each Dockerfile example. Nodejs app Dockerfile example: FROM node:argon # Create app directory RUN mkdir -p /usr/src/app WORKDIR /usr/src/app # Install app dependencies COPY package.json /usr/src/app/ RUN npm install # Bundle app source COPY . /usr/src/app EXPOSE 8080 CMD [ \"npm\", \"start\" ] Nginx Dockerfile example: FROM debian:jessie MAINTAINER NGINX Docker Maintainers \"docker-maint@nginx.com\" ENV NGINX_VERSION 1.11.7-1~jessie RUN apt-key adv --keyserver hkp://pgp.mit.edu:80 --recv-keys 573BFD6B3D8FBC641079A6ABABF5BD827BD9BF62 \\ && echo \"deb http://nginx.org/packages/mainline/debian/ jessie nginx\" >> /etc/apt/sources.list \\ && apt-get update \\ && apt-get install --no-install-recommends --no-install-suggests -y \\ ca-certificates \\ nginx=${NGINX_VERSION} \\ nginx-module-xslt \\ nginx-module-geoip \\ nginx-module-image-filter \\ nginx-module-perl \\ nginx-module-njs \\ gettext-base \\ && rm -rf /var/lib/apt/lists/* # forward request and error logs to docker log collector RUN ln -sf /dev/stdout /var/log/nginx/access.log \\ && ln -sf /dev/stderr /var/log/nginx/error.log EXPOSE 80 443 CMD [ \"nginx\", \"-g\", \"daemon off;\" ] Ejercicios: 1. Crear un archivo con el nombre index.js con el siguiente contenido: var os = require(\"os\"); var hostname = os.hostname(); console.log(\"Un saludo desde \" + hostname); Crear un archivo con el nombre Dockerfile con el siguiente contenido. FROM alpine RUN apk update && apk adk nodejs COPY . /app WORKDIR /app CMD [\"node\",\"index.js\"] Con el comando build construimos la imagen que seguir\u00e1 el script configurado en el Dockerfile que se busca en el directorio actual con el \u00faltimo punto docker image build -t hello:v0.1 . Sending build context to Docker daemon 3.072kB Step 1/5 : FROM alpine ---> 3fd9065eaf02 Step 2/5 : RUN apk update && apk add nodejs ---> Running in 867c66ddedd4 fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/main/x86_64/APKINDEX.tar.gz fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/community/x86_64/APKINDEX.tar.gz v3.7.0-190-g3da66f61a4 [http://dl-cdn.alpinelinux.org/alpine/v3.7/main] v3.7.0-184-ge62f3c3781 [http://dl-cdn.alpinelinux.org/alpine/v3.7/community] OK: 9054 distinct packages available (1/10) Installing ca-certificates (20171114-r0) (2/10) Installing nodejs-npm (8.9.3-r1) (3/10) Installing c-ares (1.13.0-r0) (4/10) Installing libcrypto1.0 (1.0.2o-r0) (5/10) Installing libgcc (6.4.0-r5) (6/10) Installing http-parser (2.7.1-r1) (7/10) Installing libssl1.0 (1.0.2o-r0) (8/10) Installing libstdc++ (6.4.0-r5) (9/10) Installing libuv (1.17.0-r0) (10/10) Installing nodejs (8.9.3-r1) Executing busybox-1.27.2-r7.trigger Executing ca-certificates-20171114-r0.trigger OK: 61 MiB in 21 packages Removing intermediate container 867c66ddedd4 ---> 9f2675ec7ebd Step 3/5 : COPY . /app ---> 3dfd8536a240 Step 4/5 : WORKDIR /app Removing intermediate container c56e9d8a8eb2 ---> 6e9870377075 Step 5/5 : CMD [\"node\",\"index.js\"] ---> Running in 8b80c4c4109d Removing intermediate container 8b80c4c4109d ---> 14ddb4369169 Successfully built 14ddb4369169 Successfully tagged hello:v0.1 Con el comando docker image ls se puede ver la imagen reci\u00e9n creada: REPOSITORY TAG IMAGE ID CREATED SIZE hello v0.1 14ddb4369169 About a minute ago 50.2MB docker container run hello:v0.1 Referencias: https://docs.docker.com/engine/getstarted/step_four/ https://docs.docker.com/engine/tutorials/dockerimages/ https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/","title":"Crear usando Dockerfile"},{"location":"chapter03/04crear-dockerfile/#crear-usando-dockerfile","text":"Give a sysadmin an image and their app will be up-to-date for a day, give a sysadmin a Dockerfile and their app will always be up-to-date Dockerfile es un archivo de texto que contiene un conjunto de instrucciones o comandos para la creaci\u00f3n de una imagen docker. Llamando a la funci\u00f3n docker build se leen las instrucciones del Dockerfile y se construye una imagen que se guardar\u00e1 en el repositorio local.","title":"Crear usando Dockerfile"},{"location":"chapter03/04crear-dockerfile/#uso-de-dockerfile","text":"Para la construcci\u00f3n de una imagen se utiliza el comando docker build ${CONTEXT} . El ${CONTEXT} son todos los archivos que necesita el Dockerfile para construir la imagen; puede ser una carpeta de nuestra propia m\u00e1quina o una URL de un repositorio git. El proceso de build lo ejecuta Docker Daemon y no el utilitario docker. Todo el ${CONTEXT} es enviado repulsivamente al docker daemon, por lo que no es recomendable utilizar un path con demasiados archivos, ya que todos ser\u00e1n enviados. El archivo Dockerfile debe estar localizado en el ra\u00edz del ${CONTEXT} Tambi\u00e9n se puede utilizar un archivo .dockerignore para especificar los archivos y carpetas que deben ser excluidos del proceso de construcci\u00f3n de la imagen y que no ser\u00e1n enviados al docker daemon, lo que mejorar\u00e1 la performance del proceso de build .","title":"Uso de Dockerfile"},{"location":"chapter03/04crear-dockerfile/#build","text":"El Dockerfile siempre parte de una imagen creada, mediante la instrucci\u00f3n FROM . FROM node:latest Con esta sola instrucci\u00f3n ya podemos crear una imagen, utilizando como ${CONTEXT} el directorio actual: $ docker build . Sending build context to Docker daemon 2.048 kB Step 1 : FROM node:latest ---> 36dc1bb7a52b Successfully built 36dc1bb7a52b Es posible indicar la ubicaci\u00f3n del Dockerfile con el argumento -f : docker build -f image/Dockerfile image/ Tambi\u00e9n podemos ponerle nombre o etiquetar la imagen a la vez que la construimos utilizando el argumento -t y el nombre que le daremos, en el formato -t ${tag}:${version} : $ docker build -t pilasguru/nodejs . $ docker build -t pilasguru/nodejs:0.0.1 . Una vez constru\u00edda podemos revisar que la imagen est\u00e9 en nuestro repositorio $ docker images pilasguru/nodejs REPOSITORY TAG IMAGE ID CREATED SIZE Pilasguru/nodejs 0.0.1 38dc1bb7a34c 2 weeks ago 655.5 MB Pilasguru/nodejs latest 38dc1bb7a34c 2 weeks ago 655.5 MB","title":"Build"},{"location":"chapter03/04crear-dockerfile/#estructura-del-dockerfile","text":"El formato del archivo Dockerfile es: # Comentario INSTRUCCION argument1 argumento2 argumento3 ... La INSTRUCCION no es case-sensitive pero por costumbre se suele usar en may\u00fascula. El orden de las instrucciones es importante ya que debe seguir el orden del proceso de construcci\u00f3n de la imagen.","title":"Estructura del Dockerfile"},{"location":"chapter03/04crear-dockerfile/#estructura-del-dockerignore","text":"El archivo .dockerignore tiene un formato como el archivo .gitignore y es un listado por rengl\u00f3n de los archivos o carpetas que son ignorados: # comentario */temp* */*/temp* temp? testing/ .git/ Los asteriscos se utilizan como comodines e incluyen tanto archivos, carpetas y en ese caso las sub-carpetas.","title":"Estructura del .dockerignore"},{"location":"chapter03/04crear-dockerfile/#instrucciones-del-dockerfile","text":"","title":"Instrucciones del Dockerfile"},{"location":"chapter03/04crear-dockerfile/#from","text":"Un Dockerfile v\u00e1lido debe tener este instrucci\u00f3n como su primer instrucci\u00f3n e indica la imagen que se utilizar\u00e1 para construir la nueva imagen. Docker daemon primero verificar\u00e1 si la imagen existe localmente, si no proceder\u00e1 a descargarla de docker hub. Se puede utilizar de tres formas: FROM <imagen> FROM <imagen:tag> FROM <imagen>@<digest> FROM debe ser la primer l\u00ednea no comentada en el Dockerfile. Se puede utilizar m\u00faltiples veces en el mismo Dockerfile. Tanto el tag como digest son opcionales y permiten tratar de obtener la imagen exacta, pero de no estar disponible se usar\u00e1 la \u00faltima ( latest )","title":"FROM"},{"location":"chapter03/04crear-dockerfile/#maintainer","text":"Permite indicar el autor de la imagen y se utiliza asi: MAINTAINER <nombre>","title":"MAINTAINER"},{"location":"chapter03/04crear-dockerfile/#run","text":"Permite indicar comandos que ser\u00e1n ejecutados en una nueva capa sobre la imagen (del FROM) en el proceso de construcci\u00f3n y ese resultado ser\u00e1 guardado para pasarlo, opcionalmente, a un siguiente RUN que volver\u00e1 a crear una nueva capa. RUN tiene dos formatos: shell o exec : RUN <comando> es el formato shell. El comando se ejecutar\u00e1 en un shell que por defecto es /bin/sh -c de Linux o cmd /S /C de Windows. RUN [\u201cejecutable\u201d, \u201cargumento1\u201d, \u201cargumento2\u201d, \u201cargumento3\u201d \u2026] Un ejemplo de Dockerfile hasta ahora, quedar\u00eda construido de la siguiente forma: # Ejemplo # ---------- FROM node:latest MAINTAINER pilasguru RUN /bin/sh -c 'echo \"*** hello Dockerfile!! ***\"' RUN [\"npm\", \"--version\"] Creando una imagen con este ejemplo, tendremos la siguiente salida: \u279c docker build -t pilasguru/nodejs:0.0.3 . \u2026 Step 3 : RUN /bin/sh -c 'echo \"*** hello Dockerfile!! ***\"' ---> Running in 6ebfa85f7683 *** hello Dockerfile!! *** \u2026 Step 4 : RUN npm --version ---> Running in fc9dab7cf8c2 3.10.10 \u2026","title":"RUN"},{"location":"chapter03/04crear-dockerfile/#label","text":"Esta instrucci\u00f3n incluye metadatos a la imagen en el formato de pares llave-valor: LABEL <llave>=<valor> <llave>=<valor> <llae>=<valor> ... Y se pueden utilizar m\u00faltiples l\u00edneas de LABEL: LABEL \"com.ejemplo.imagen\"=\"Node JS imagen LABEL ejemplo\" LABEL version=\"0.0.4\" LABEL descripcion=\"valores pueden ser \\ separados en varias l\u00edneas\" Y por supuesto que se pueden indicar varios pares de llaves=valor en la misma instrucci\u00f3n LABEL. Veamos la construcci\u00f3n de una imagen y sus metadatos: $ docker build -t pilasguru/nodejs:0.0.3 . --no-cache=true $ docker inspect pilasguru/nodejs:0.0.3 \u2026 \"Labels\": { \"com.ejemplo.imagen\": \"Node JS image LABEL ejemplo\", \"descripcion\": \"valores pueden ser Separados en varias l\u00edneas\", \"version\": \"0.0.4\" } \u2026","title":"LABEL"},{"location":"chapter03/04crear-dockerfile/#expose","text":"Esta instrucci\u00f3n informa a Docker que el contenedor escuchar\u00e1 en un determinado puerto cuando est\u00e9 corriendo. EXPOSE <port> [<port>...] No significa que el puerto ser\u00e1 accesible desde el host. Para construir la red, se debe utilizar el argumento -p que publicar\u00e1 el punto al correr docker.","title":"EXPOSE"},{"location":"chapter03/04crear-dockerfile/#env","text":"Permite configurar variables de entorno en el contenedor cuando est\u00e9 corriendo. ENV mysql_password passw0rd ENV src_folder ./src/app Se pueden consultar las declaraciones de ENV con el comando inspect : $ docker inspect linoxide/nodejs:0.0.3 \u2026 \"Env\": [ \"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", \"NPM_CONFIG_LOGLEVEL=info\", \"NODE_VERSION=7.2.1\", \"mysql_password=passw0rd\", \"src_folder=./src/app\" ] \u2026","title":"ENV"},{"location":"chapter03/04crear-dockerfile/#add","text":"La instrucci\u00f3n ADD copia nuevos archivos, directorios o archivos remotos (desde una URL) desde un <src> y los agrega a la imagen en el lugar indicado en <dest> . Ejemplos: ADD . /app/ ADD [ \"dir con espacios/\" \"/app/\" ] En los dos ejemplos de arriba se copian los archivos de los directorios indicados en la carpeta /app/ dentro de la imagen. Si el <dest> no finaliza barra al final, se considera un archivo y en el se escribir\u00e1 el contenido de <src> . Si <dest> no existe, ser\u00e1 creado. Se permite el uso de asteriscos en <src> como ser arch* o readm?.txt . Si el origen <src> es un compactado (tar, gzip, bzip2 o xz) la ejecuci\u00f3n de ADD lo descompactar\u00e1 dentro de <dest> .","title":"ADD"},{"location":"chapter03/04crear-dockerfile/#copy","text":"COPY es muy similar a ADD: hace lo mismo y tiene el mismo formato. La diferencia es que COPY no acepta URLs como <src> y en caso de ser un archivo compactado, no lo descompactar\u00e1 al copiarlo dentro de la imagen.","title":"COPY"},{"location":"chapter03/04crear-dockerfile/#entrypoint","text":"Este comando permite especificar un comando que ser\u00e1 siempre ejecutado cada vez que se inicie el container. ENTRYPOINT [\"/bin/echo\", \"Hola pilasguru\"] $ docker build -t pilasguru/nodejs:0.0.3 . --no-cache=true $ docker run -it --name minodejs pilasguru/nodejs:0.0.3 Hola pilasguru Tenga en cuenta que solamente un ENTRYPOINT es permitido en el Dockerfile.","title":"ENTRYPOINT"},{"location":"chapter03/04crear-dockerfile/#cmd","text":"Al igual que ENTRYPOINT permite especificar comandos a ejecutar cuando se inicie el container y tambi\u00e9n, solamente un CMD es permitido en el Dockerfile. La caracter\u00edstica de CMD es que ser\u00e1 omitido en caso de que el contenedor se inicie especificando otro comando. Si un Dockerfile especifica: ENTRYPOINT [\"/bin/echo\", \"Hola pilasguru\"] CMD [\"/bin/echo\" \"Hola Mundo!!\"] Y constru\u00edmos la imagen: $ docker build -t pilasguru/nodejs:0.0.3 . --no-cache=true Y ejecutamos: $ docker run -it --name minodejs pilasguru/nodejs:0.0.3 Hola pilasguru Hola Mundo!! Ahora si creamos un segundo comando, pero indicando un comando: $ docker run -it --name minodejs pilasguru/nodejs:0.0.3 echo \"Que onda!\" Hola pilasguru Que onda!","title":"CMD"},{"location":"chapter03/04crear-dockerfile/#volume","text":"La instrucci\u00f3n VOLUME creara un punto de montado con el nombre especificado y tendr\u00e1 el filesystem externo al contenedor VOLUME /var/log","title":"VOLUME"},{"location":"chapter03/04crear-dockerfile/#user","text":"La instrucci\u00f3n USER seguido del nombre o UID indica bajo que usuario correr\u00e1n las instrucciones RUN, CMD o ENTRYPOINT.","title":"USER"},{"location":"chapter03/04crear-dockerfile/#workdir","text":"WORKDIR permite indicar el directorio en el cual los comandos de RUN, CMD, ENTRYPOINT, COPY y ADD ser\u00e1n ejecutados. Si el directorio WORKDIR no existe, ser\u00e1 creado. WORKDIR puede ser visto como el home del contenedor","title":"WORKDIR"},{"location":"chapter03/04crear-dockerfile/#ejemplos-de-dockerfile","text":"Please see the comments in each Dockerfile example.","title":"Ejemplos de Dockerfile"},{"location":"chapter03/04crear-dockerfile/#nodejs-app-dockerfile-example","text":"FROM node:argon # Create app directory RUN mkdir -p /usr/src/app WORKDIR /usr/src/app # Install app dependencies COPY package.json /usr/src/app/ RUN npm install # Bundle app source COPY . /usr/src/app EXPOSE 8080 CMD [ \"npm\", \"start\" ]","title":"Nodejs app Dockerfile example:"},{"location":"chapter03/04crear-dockerfile/#nginx-dockerfile-example","text":"FROM debian:jessie MAINTAINER NGINX Docker Maintainers \"docker-maint@nginx.com\" ENV NGINX_VERSION 1.11.7-1~jessie RUN apt-key adv --keyserver hkp://pgp.mit.edu:80 --recv-keys 573BFD6B3D8FBC641079A6ABABF5BD827BD9BF62 \\ && echo \"deb http://nginx.org/packages/mainline/debian/ jessie nginx\" >> /etc/apt/sources.list \\ && apt-get update \\ && apt-get install --no-install-recommends --no-install-suggests -y \\ ca-certificates \\ nginx=${NGINX_VERSION} \\ nginx-module-xslt \\ nginx-module-geoip \\ nginx-module-image-filter \\ nginx-module-perl \\ nginx-module-njs \\ gettext-base \\ && rm -rf /var/lib/apt/lists/* # forward request and error logs to docker log collector RUN ln -sf /dev/stdout /var/log/nginx/access.log \\ && ln -sf /dev/stderr /var/log/nginx/error.log EXPOSE 80 443 CMD [ \"nginx\", \"-g\", \"daemon off;\" ]","title":"Nginx Dockerfile example:"},{"location":"chapter03/04crear-dockerfile/#ejercicios","text":"","title":"Ejercicios:"},{"location":"chapter03/04crear-dockerfile/#1","text":"Crear un archivo con el nombre index.js con el siguiente contenido: var os = require(\"os\"); var hostname = os.hostname(); console.log(\"Un saludo desde \" + hostname); Crear un archivo con el nombre Dockerfile con el siguiente contenido. FROM alpine RUN apk update && apk adk nodejs COPY . /app WORKDIR /app CMD [\"node\",\"index.js\"] Con el comando build construimos la imagen que seguir\u00e1 el script configurado en el Dockerfile que se busca en el directorio actual con el \u00faltimo punto docker image build -t hello:v0.1 . Sending build context to Docker daemon 3.072kB Step 1/5 : FROM alpine ---> 3fd9065eaf02 Step 2/5 : RUN apk update && apk add nodejs ---> Running in 867c66ddedd4 fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/main/x86_64/APKINDEX.tar.gz fetch http://dl-cdn.alpinelinux.org/alpine/v3.7/community/x86_64/APKINDEX.tar.gz v3.7.0-190-g3da66f61a4 [http://dl-cdn.alpinelinux.org/alpine/v3.7/main] v3.7.0-184-ge62f3c3781 [http://dl-cdn.alpinelinux.org/alpine/v3.7/community] OK: 9054 distinct packages available (1/10) Installing ca-certificates (20171114-r0) (2/10) Installing nodejs-npm (8.9.3-r1) (3/10) Installing c-ares (1.13.0-r0) (4/10) Installing libcrypto1.0 (1.0.2o-r0) (5/10) Installing libgcc (6.4.0-r5) (6/10) Installing http-parser (2.7.1-r1) (7/10) Installing libssl1.0 (1.0.2o-r0) (8/10) Installing libstdc++ (6.4.0-r5) (9/10) Installing libuv (1.17.0-r0) (10/10) Installing nodejs (8.9.3-r1) Executing busybox-1.27.2-r7.trigger Executing ca-certificates-20171114-r0.trigger OK: 61 MiB in 21 packages Removing intermediate container 867c66ddedd4 ---> 9f2675ec7ebd Step 3/5 : COPY . /app ---> 3dfd8536a240 Step 4/5 : WORKDIR /app Removing intermediate container c56e9d8a8eb2 ---> 6e9870377075 Step 5/5 : CMD [\"node\",\"index.js\"] ---> Running in 8b80c4c4109d Removing intermediate container 8b80c4c4109d ---> 14ddb4369169 Successfully built 14ddb4369169 Successfully tagged hello:v0.1 Con el comando docker image ls se puede ver la imagen reci\u00e9n creada: REPOSITORY TAG IMAGE ID CREATED SIZE hello v0.1 14ddb4369169 About a minute ago 50.2MB docker container run hello:v0.1","title":"1."},{"location":"chapter03/04crear-dockerfile/#referencias","text":"https://docs.docker.com/engine/getstarted/step_four/ https://docs.docker.com/engine/tutorials/dockerimages/ https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/","title":"Referencias:"},{"location":"chapter03/05capas/","text":"Capas de las im\u00e1genes docker image history alpine echo \"console.log(\\\"version imagen v0.2\\\");\" >> index.js docker image build -t hello:v0.2 . docker image ls docker container run hello:v0.2 docker image history hello:v0.2 docker image inspect alpine docker image inspect --format \"{{ json .RootFS.Layers }}\" alpine docker image inspect --format \"{{ json .RootFS.Layers }}\" hello:v0.2","title":"Capas de las im\u00e1genes"},{"location":"chapter03/05capas/#capas-de-las-imagenes","text":"docker image history alpine echo \"console.log(\\\"version imagen v0.2\\\");\" >> index.js docker image build -t hello:v0.2 . docker image ls docker container run hello:v0.2 docker image history hello:v0.2 docker image inspect alpine docker image inspect --format \"{{ json .RootFS.Layers }}\" alpine docker image inspect --format \"{{ json .RootFS.Layers }}\" hello:v0.2","title":"Capas de las im\u00e1genes"},{"location":"chapter03/06subir/","text":"Subir (compartir) im\u00e1genes propias Para compartir im\u00e1genes en Docker Hub se debe poseer una cuenta y primeramente estar logrado: $ docker login Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. Username: pilasguru Password: Login Succeeded Una vez ingresado, la im\u00e1genes debe tener un nombre (tag) formado por usuario/nombre-imagen , en mi caso: docker tag localtest:latest pilasguru/test Reci\u00e9n con este nombre y el comando push se podr\u00e1 subir la imagen a Docker Hub, que tomar\u00e1 el nombre de usuario de la primera parte del nombre de la imagen: $ docker push pilasguru/test The push refers to repository [docker.io/pilasguru/test] cd7100a72410: Preparing latest: digest: sha256:8c03bb07a531c53ad7d0f6e7041b64d81f99c6e493cb39abba56d956b40eacbc size: 528 Referencias: https://docs.docker.com/engine/reference/commandline/push/ https://docs.docker.com/docker-cloud/builds/push-images/","title":"Subir (compartir) im\u00e1genes propias"},{"location":"chapter03/06subir/#subir-compartir-imagenes-propias","text":"Para compartir im\u00e1genes en Docker Hub se debe poseer una cuenta y primeramente estar logrado: $ docker login Login with your Docker ID to push and pull images from Docker Hub. If you don't have a Docker ID, head over to https://hub.docker.com to create one. Username: pilasguru Password: Login Succeeded Una vez ingresado, la im\u00e1genes debe tener un nombre (tag) formado por usuario/nombre-imagen , en mi caso: docker tag localtest:latest pilasguru/test Reci\u00e9n con este nombre y el comando push se podr\u00e1 subir la imagen a Docker Hub, que tomar\u00e1 el nombre de usuario de la primera parte del nombre de la imagen: $ docker push pilasguru/test The push refers to repository [docker.io/pilasguru/test] cd7100a72410: Preparing latest: digest: sha256:8c03bb07a531c53ad7d0f6e7041b64d81f99c6e493cb39abba56d956b40eacbc size: 528","title":"Subir (compartir) im\u00e1genes propias"},{"location":"chapter03/06subir/#referencias","text":"https://docs.docker.com/engine/reference/commandline/push/ https://docs.docker.com/docker-cloud/builds/push-images/","title":"Referencias:"},{"location":"chapter03/","text":"Im\u00e1genes docker El sistema de im\u00e1genes de docker permite guardar contenedores docker prontos para utilizar (llamados im\u00e1genes ) en un banco local o remoto. Cuando el banco de im\u00e1genes es remoto se denomina repositorio y tiene como objetivo compartir im\u00e1genes entre distintos sistemas, grupos de usuarios o, inclusive, distribuci\u00f3n de software pronto para poner a correr. El banco de im\u00e1genes local permite guardar las im\u00e1genes que se descargan de los repositorios y tambi\u00e9n las que son creadas localmente en el host donde se ejecuta docker. Referencias: https://docs.docker.com/engine/reference/commandline/images/ https://docs.docker.com/engine/tutorials/dockerimages/","title":"Im\u00e1genes docker"},{"location":"chapter03/#imagenes-docker","text":"El sistema de im\u00e1genes de docker permite guardar contenedores docker prontos para utilizar (llamados im\u00e1genes ) en un banco local o remoto. Cuando el banco de im\u00e1genes es remoto se denomina repositorio y tiene como objetivo compartir im\u00e1genes entre distintos sistemas, grupos de usuarios o, inclusive, distribuci\u00f3n de software pronto para poner a correr. El banco de im\u00e1genes local permite guardar las im\u00e1genes que se descargan de los repositorios y tambi\u00e9n las que son creadas localmente en el host donde se ejecuta docker.","title":"Im\u00e1genes docker"},{"location":"chapter03/#referencias","text":"https://docs.docker.com/engine/reference/commandline/images/ https://docs.docker.com/engine/tutorials/dockerimages/","title":"Referencias:"},{"location":"chapter04/01bind/","text":"Espacio de host Montar una carpeta desde del host directamente dentro de un contenedor se hace utilizando la opci\u00f3n -v path-host:path-container Y se configura al lanzar el contenedor: docker container run --name web-nginx -v /opt/website:/usr/share/nginx/html:ro -d nginx Esto har\u00e1 que la carpeta del host /opt/website quede presentada como la carpeta /usr/share/nginx/html en el contenedor. El atributo :ro har\u00e1 que para el contenedor sea un espacio de solo lectura. Referencias: bind mount","title":"Espacio de host"},{"location":"chapter04/01bind/#espacio-de-host","text":"Montar una carpeta desde del host directamente dentro de un contenedor se hace utilizando la opci\u00f3n -v path-host:path-container Y se configura al lanzar el contenedor: docker container run --name web-nginx -v /opt/website:/usr/share/nginx/html:ro -d nginx Esto har\u00e1 que la carpeta del host /opt/website quede presentada como la carpeta /usr/share/nginx/html en el contenedor. El atributo :ro har\u00e1 que para el contenedor sea un espacio de solo lectura.","title":"Espacio de host"},{"location":"chapter04/01bind/#referencias","text":"bind mount","title":"Referencias:"},{"location":"chapter04/02volume/","text":"Volume Los vol\u00famenes son recursos administrador por docker directamente y que pueden ser vistos como un disco montado dentro de los contenedores: Creaci\u00f3n La creaci\u00f3n de un volume se puede realizar de tres formas diferentes: 1. Nuevo vol\u00famen Con la opci\u00f3n volume create se puede crear un volumen con un nombre dado, para luego utilizar: docker volume create MisDatos Y puede ser visto en el listado de vol\u00famenes disponibles: $ docker volume ls DRIVER VOLUME NAME local MisDatos 2. Creaci\u00f3n con ejecuci\u00f3n Esta opci\u00f3n es semejante a bind mount pues se usa con la opci\u00f3n -v pero se indica un nombre en lugar de un path del host; esto har\u00e1 que docker cree ese evolumen: docker run -d -v DataVol:/opt/app/data nginx Que har\u00e1 que el volumen quede presentado dentro del contenedor en la carpeta /opt/app/data . Podemos analizar su configuraci\u00f3n: $ docker volume inspect DataVol [ { \"CreatedAt\": \"2018-06-04T21:31:46Z\", \"Driver\": \"local\", \"Labels\": null, \"Mountpoint\": \"/var/lib/docker/volumes/DataVol/_data\", \"Name\": \"DataVol\", \"Options\": null, \"Scope\": \"local\" } ] Y dentro del contenedor lo podemos consultar con mount: /dev/sda1 on /opt/app/data type ext4 (rw,relatime,data=ordered) 3. Volumen an\u00f3nimo El volumen an\u00f3nimo es un espacio de volumen creado por docker (para evitar que los datos se borren al borrar el contenedor), pero que tiene un nombre aleatorio asignado por docker. docker run -d -v /opt/app/data nginx Y podemos consultar en la lista de vol\u00famenes disponibles: $ docker volume ls DRIVER VOLUME NAME local 9af22968682baefc5c10461d1b3aff226c2a917fe3222ac8f90dd768e1ed5238 Re-utilizar un volumen creado Limpieza Ejercicios: 1. 2. Referencias: https://docs.docker.com/storage/volumes/","title":"Volume"},{"location":"chapter04/02volume/#volume","text":"Los vol\u00famenes son recursos administrador por docker directamente y que pueden ser vistos como un disco montado dentro de los contenedores:","title":"Volume"},{"location":"chapter04/02volume/#creacion","text":"La creaci\u00f3n de un volume se puede realizar de tres formas diferentes:","title":"Creaci\u00f3n"},{"location":"chapter04/02volume/#1-nuevo-volumen","text":"Con la opci\u00f3n volume create se puede crear un volumen con un nombre dado, para luego utilizar: docker volume create MisDatos Y puede ser visto en el listado de vol\u00famenes disponibles: $ docker volume ls DRIVER VOLUME NAME local MisDatos","title":"1. Nuevo vol\u00famen"},{"location":"chapter04/02volume/#2-creacion-con-ejecucion","text":"Esta opci\u00f3n es semejante a bind mount pues se usa con la opci\u00f3n -v pero se indica un nombre en lugar de un path del host; esto har\u00e1 que docker cree ese evolumen: docker run -d -v DataVol:/opt/app/data nginx Que har\u00e1 que el volumen quede presentado dentro del contenedor en la carpeta /opt/app/data . Podemos analizar su configuraci\u00f3n: $ docker volume inspect DataVol [ { \"CreatedAt\": \"2018-06-04T21:31:46Z\", \"Driver\": \"local\", \"Labels\": null, \"Mountpoint\": \"/var/lib/docker/volumes/DataVol/_data\", \"Name\": \"DataVol\", \"Options\": null, \"Scope\": \"local\" } ] Y dentro del contenedor lo podemos consultar con mount: /dev/sda1 on /opt/app/data type ext4 (rw,relatime,data=ordered)","title":"2. Creaci\u00f3n con ejecuci\u00f3n"},{"location":"chapter04/02volume/#3-volumen-anonimo","text":"El volumen an\u00f3nimo es un espacio de volumen creado por docker (para evitar que los datos se borren al borrar el contenedor), pero que tiene un nombre aleatorio asignado por docker. docker run -d -v /opt/app/data nginx Y podemos consultar en la lista de vol\u00famenes disponibles: $ docker volume ls DRIVER VOLUME NAME local 9af22968682baefc5c10461d1b3aff226c2a917fe3222ac8f90dd768e1ed5238","title":"3. Volumen an\u00f3nimo"},{"location":"chapter04/02volume/#re-utilizar-un-volumen-creado","text":"","title":"Re-utilizar un volumen creado"},{"location":"chapter04/02volume/#limpieza","text":"","title":"Limpieza"},{"location":"chapter04/02volume/#ejercicios","text":"","title":"Ejercicios:"},{"location":"chapter04/02volume/#1","text":"","title":"1."},{"location":"chapter04/02volume/#2","text":"","title":"2."},{"location":"chapter04/02volume/#referencias","text":"https://docs.docker.com/storage/volumes/","title":"Referencias:"},{"location":"chapter04/","text":"Los containers tienen un filesystem esf\u00edmero , es decir: el filesystem va a estar disponible mientras el container exista. Una vez que el container se borre, el filesystem tambi\u00e9n ser\u00e1 eliminado. Pero evidentemente, la idea es poder iniciar, detener y borrar containers sin perder datos. Es decir, necesitamos persistir los datos fuera del contenedor. Existen dos formas de hacerlo: bind mount permite usar un carpeta (path) del host y presentarlo dentro del container en un punto de montado, por ejemplo /app . Es la forma m\u00e1s f\u00e1cil de conectar el filesystem del host con el contenedor. El bind mount se especifica en el momento de lanzar el contenedor y requiere realizar los procesos de respaldo, migraci\u00f3n, etc. con herramientas fuera de docker. volume es un dispositivo de disco externo el contenedor creado por docker y puede ser utilizado por otros contenedores simplemente indicando la ruta (nombre).","title":"Index"},{"location":"chapter05/01redcerrado/","text":"Contenedores cerrados Los procesos que corren dentro de un mismo contenedor pueden comunicarse entre ellos mediante la interfaz loopback (localhost). Pero en los contenedores cerrados no hay comunicaci\u00f3n ni saliente ni entrante al contenedor; es decir el contenedor no se puede comunicar ni con internet ni con otros contenedores. Para crear un contenedor en una red cerrada utilizamos el argumento --net none cuando lo creamos: docker run --net none -it alpine:latest /bin/sh Este ejemplo abre un shell, pero podr\u00edamos asignarle comandos o tareas ya automatizadas en la imagen que levantamos. Por ejemplo se pueden utilizar para realizar respaldos, actualizar bases de datos, obtener y desplegar estad\u00edsticas, y cualquier otra tarea que no requiera conexi\u00f3n de red.","title":"Contenedores cerrados"},{"location":"chapter05/01redcerrado/#contenedores-cerrados","text":"Los procesos que corren dentro de un mismo contenedor pueden comunicarse entre ellos mediante la interfaz loopback (localhost). Pero en los contenedores cerrados no hay comunicaci\u00f3n ni saliente ni entrante al contenedor; es decir el contenedor no se puede comunicar ni con internet ni con otros contenedores. Para crear un contenedor en una red cerrada utilizamos el argumento --net none cuando lo creamos: docker run --net none -it alpine:latest /bin/sh Este ejemplo abre un shell, pero podr\u00edamos asignarle comandos o tareas ya automatizadas en la imagen que levantamos. Por ejemplo se pueden utilizar para realizar respaldos, actualizar bases de datos, obtener y desplegar estad\u00edsticas, y cualquier otra tarea que no requiera conexi\u00f3n de red.","title":"Contenedores cerrados"},{"location":"chapter05/02redabierto/","text":"Contenedores abiertos Los contenedores abiertos se deben evitar en lo posible. Los contenedores abiertos se conectan directamente al sistema de red del host. Para los contenedores abiertos se deben tomar precauciones de aislamiento adicional, ya que se tiene un acceso total a las redes y las interfaces el host. Para crear un contenedor en una red abierta utilizamos el argumento --net host cuando lo creamos: $ docker run --net host -it alpine:latest /bin/sh / # ip a s 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 02:e4:ac:f5:39:a9 brd ff:ff:ff:ff:ff:ff inet 10.0.2.15/24 brd 10.0.2.255 scope global enp0s3 valid_lft forever preferred_lft forever inet6 fe80::e4:acff:fef5:39a9/64 scope link valid_lft forever preferred_lft forever 3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN link/ether 02:42:59:1a:e2:84 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:59ff:fe1a:e284/64 scope link valid_lft forever preferred_lft forever Este container solamente ejecuta un shell, pero muestra como se tiene acceso a todas las interfaces del host en forma transparente.","title":"Contenedores abiertos"},{"location":"chapter05/02redabierto/#contenedores-abiertos","text":"Los contenedores abiertos se deben evitar en lo posible. Los contenedores abiertos se conectan directamente al sistema de red del host. Para los contenedores abiertos se deben tomar precauciones de aislamiento adicional, ya que se tiene un acceso total a las redes y las interfaces el host. Para crear un contenedor en una red abierta utilizamos el argumento --net host cuando lo creamos: $ docker run --net host -it alpine:latest /bin/sh / # ip a s 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever inet6 ::1/128 scope host valid_lft forever preferred_lft forever 2: enp0s3: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP qlen 1000 link/ether 02:e4:ac:f5:39:a9 brd ff:ff:ff:ff:ff:ff inet 10.0.2.15/24 brd 10.0.2.255 scope global enp0s3 valid_lft forever preferred_lft forever inet6 fe80::e4:acff:fef5:39a9/64 scope link valid_lft forever preferred_lft forever 3: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN link/ether 02:42:59:1a:e2:84 brd ff:ff:ff:ff:ff:ff inet 172.17.0.1/16 brd 172.17.255.255 scope global docker0 valid_lft forever preferred_lft forever inet6 fe80::42:59ff:fe1a:e284/64 scope link valid_lft forever preferred_lft forever Este container solamente ejecuta un shell, pero muestra como se tiene acceso a todas las interfaces del host en forma transparente.","title":"Contenedores abiertos"},{"location":"chapter05/03redbridge/","text":"Contenedores detr\u00e1s de bridges Son los contenedores por defecto que se crean con docker. Cuando se corre Docker Daemon se crea un bridge ( docker0 ) y los contenedores que se van creando son autom\u00e1ticamente conectados a ese bridge y se le asigna una IP privada. La comunicaci\u00f3n entre contenedores conectados al mismo bridge se produce por estar en la misma sub-red. La conexi\u00f3n hacia internet se produce nat utilizando la IP p\u00fablica del host. Docker permite la creaci\u00f3n de bridges y sub-redes mediante el comando docker network Para crear un contenedor en una detr\u00e1s de un bridge no se necesita indicar ning\u00fan argumento, ya que es el tipo de contenedor que se levanta por defecto. Sin embargo, se puede especificar el argumento --net bridge al crear el contenedor: $ docker run -it alpine:latest /bin/sh / # ip a s 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 70: eth0@if71: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue state UP link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever $ docker run --net bridge alpine:latest Crear una red y bridge Es posible crear una propia red con un bridge e indicarle a docker que la use, en lugar de utilizar la que configura por defecto (docker0). Para crear una nueva red de tipo bridge cualquiera de estos tres comandos es equivalente: docker network create mired docker network create -d mired docker network create --driver bridge mired El argumento -d o --driver permite indicar el tipo de red a crear, por defecto es bridge . Para crear un bridge con toda la configuraci\u00f3n de red necesaria: docker network create \\ --driver bridge \\ --subnet=192.168.2.0/24 \\ --gateway=192.168.2.10 \\ nueva_red Para correr un contenedor pegado a nuestra nueva sub-red: docker run --network=nueva_red -itd --name=docker-nginx nginx Referencias: https://docs.docker.com/engine/reference/commandline/network_create/","title":"Contenedores detr\u00e1s de bridges"},{"location":"chapter05/03redbridge/#contenedores-detras-de-bridges","text":"Son los contenedores por defecto que se crean con docker. Cuando se corre Docker Daemon se crea un bridge ( docker0 ) y los contenedores que se van creando son autom\u00e1ticamente conectados a ese bridge y se le asigna una IP privada. La comunicaci\u00f3n entre contenedores conectados al mismo bridge se produce por estar en la misma sub-red. La conexi\u00f3n hacia internet se produce nat utilizando la IP p\u00fablica del host. Docker permite la creaci\u00f3n de bridges y sub-redes mediante el comando docker network Para crear un contenedor en una detr\u00e1s de un bridge no se necesita indicar ning\u00fan argumento, ya que es el tipo de contenedor que se levanta por defecto. Sin embargo, se puede especificar el argumento --net bridge al crear el contenedor: $ docker run -it alpine:latest /bin/sh / # ip a s 1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN qlen 1 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever 70: eth0@if71: <BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN> mtu 1500 qdisc noqueue state UP link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0 valid_lft forever preferred_lft forever $ docker run --net bridge alpine:latest","title":"Contenedores detr\u00e1s de bridges"},{"location":"chapter05/03redbridge/#crear-una-red-y-bridge","text":"Es posible crear una propia red con un bridge e indicarle a docker que la use, en lugar de utilizar la que configura por defecto (docker0). Para crear una nueva red de tipo bridge cualquiera de estos tres comandos es equivalente: docker network create mired docker network create -d mired docker network create --driver bridge mired El argumento -d o --driver permite indicar el tipo de red a crear, por defecto es bridge . Para crear un bridge con toda la configuraci\u00f3n de red necesaria: docker network create \\ --driver bridge \\ --subnet=192.168.2.0/24 \\ --gateway=192.168.2.10 \\ nueva_red Para correr un contenedor pegado a nuestra nueva sub-red: docker run --network=nueva_red -itd --name=docker-nginx nginx","title":"Crear una red y bridge"},{"location":"chapter05/03redbridge/#referencias","text":"https://docs.docker.com/engine/reference/commandline/network_create/","title":"Referencias:"},{"location":"chapter05/04redjuntos/","text":"Contenedores juntos En una red de contenedores juntos, multiple contenedores comparten la misma interfaz de red y loopback; como resultado podemos crear redes cerradas y levantar otros container en la misma red que se pueden comunicar unos con otros. De esta forma se pueden crear containers aislados de internet pero vinculados por red entre ellos redes. Para crear un contenedor unido a otro utilizamos el argumento --net container: nombre , como este ejemplo: Creamos un primer contenedor en una cerrado: $ docker run --name contenedor_cerrado --net none -it alpine /bin/sh Creamos un segundo contenedor peg\u00e1ndolo al creado en el paso anterior: $ docker run --net container:contenedor_cerrado -it alpine /bin/sh","title":"Contenedores juntos"},{"location":"chapter05/04redjuntos/#contenedores-juntos","text":"En una red de contenedores juntos, multiple contenedores comparten la misma interfaz de red y loopback; como resultado podemos crear redes cerradas y levantar otros container en la misma red que se pueden comunicar unos con otros. De esta forma se pueden crear containers aislados de internet pero vinculados por red entre ellos redes. Para crear un contenedor unido a otro utilizamos el argumento --net container: nombre , como este ejemplo: Creamos un primer contenedor en una cerrado: $ docker run --name contenedor_cerrado --net none -it alpine /bin/sh Creamos un segundo contenedor peg\u00e1ndolo al creado en el paso anterior: $ docker run --net container:contenedor_cerrado -it alpine /bin/sh","title":"Contenedores juntos"},{"location":"chapter05/","text":"Redes de contenedores Los contenedores suponen aislaci\u00f3n, por lo que para vincularlos tenemos cuatro tipos de opciones o formas de vinculaci\u00f3n. Contenedores cerrados ( none ) Contenedores abiertos ( host ) Contenedores detr\u00e1s de bridges ( bridge ) Contenedores juntos ( container ) Docker ofrece un sistema muy flexible de red, que permite crear nuestra propia configuraci\u00f3n, para atender necesidades espec\u00edficas. El comando network ls mostrar\u00e1 las redes disponibles $ docker network ls NETWORK ID NAME DRIVER SCOPE 67bf7f355a4e bridge bridge local 727420fae124 host host local fa2601d6c7fa none null local","title":"Redes de contenedores"},{"location":"chapter05/#redes-de-contenedores","text":"Los contenedores suponen aislaci\u00f3n, por lo que para vincularlos tenemos cuatro tipos de opciones o formas de vinculaci\u00f3n. Contenedores cerrados ( none ) Contenedores abiertos ( host ) Contenedores detr\u00e1s de bridges ( bridge ) Contenedores juntos ( container ) Docker ofrece un sistema muy flexible de red, que permite crear nuestra propia configuraci\u00f3n, para atender necesidades espec\u00edficas. El comando network ls mostrar\u00e1 las redes disponibles $ docker network ls NETWORK ID NAME DRIVER SCOPE 67bf7f355a4e bridge bridge local 727420fae124 host host local fa2601d6c7fa none null local","title":"Redes de contenedores"},{"location":"chapter06/02docker-compose/","text":"docker-compose El utilitario docker-compose primate definir y correr ambientes de multiples contenedores con Docker. Creamos un directorio para nuestro entorno: $ mkdir wpdc; cd wpdc Se basa en el archivo docker-compose.yml version: '2' services: wordpressdb: image: mariadb:latest volumes: - ../wp/database:/var/lib/mysql environment: MYSQL_ROOT_PASSWORD: rootpass MYSQL_DATABASE: wordpress wordpress: depends_on: - wordpressdb image: wordpress ports: - \"8082:80\" volumes: - ../wp/html:/var/www/html environment: WORDPRESS_DB_HOST: wordpressdb:3306 WORDPRESS_DB_PASSWORD: rootpass links: - wordpressdb:mysql Y levantamos nuestro entorno con up: $ docker-compose up -d Creating network \"wpdc_default\" with the default driver Creating wpdc_wordpressdb_1 Creating wpdc_wordpress_1 $ docker-compose ps Name Command State Ports ---------------------------------------------------------------------------------- wpdc_wordpress_1 docker-entrypoint.sh apach ... Up 0.0.0.0:8082->80/tcp wpdc_wordpressdb_1 docker-entrypoint.sh mysqld Up 3306/tcp Ejercicios 1. Cree un docker-compose.yml para levantar una aplicaci\u00f3n tomcat de ejemplo Sample Application Basados en la imagen tomcat que escucha en el puerto 8080 Referencias: https://docs.docker.com/compose/overview/ https://docs.docker.com/compose/compose-file/compose-file-v2/","title":"docker-compose"},{"location":"chapter06/02docker-compose/#docker-compose","text":"El utilitario docker-compose primate definir y correr ambientes de multiples contenedores con Docker. Creamos un directorio para nuestro entorno: $ mkdir wpdc; cd wpdc Se basa en el archivo docker-compose.yml version: '2' services: wordpressdb: image: mariadb:latest volumes: - ../wp/database:/var/lib/mysql environment: MYSQL_ROOT_PASSWORD: rootpass MYSQL_DATABASE: wordpress wordpress: depends_on: - wordpressdb image: wordpress ports: - \"8082:80\" volumes: - ../wp/html:/var/www/html environment: WORDPRESS_DB_HOST: wordpressdb:3306 WORDPRESS_DB_PASSWORD: rootpass links: - wordpressdb:mysql Y levantamos nuestro entorno con up: $ docker-compose up -d Creating network \"wpdc_default\" with the default driver Creating wpdc_wordpressdb_1 Creating wpdc_wordpress_1 $ docker-compose ps Name Command State Ports ---------------------------------------------------------------------------------- wpdc_wordpress_1 docker-entrypoint.sh apach ... Up 0.0.0.0:8082->80/tcp wpdc_wordpressdb_1 docker-entrypoint.sh mysqld Up 3306/tcp","title":"docker-compose"},{"location":"chapter06/02docker-compose/#ejercicios","text":"","title":"Ejercicios"},{"location":"chapter06/02docker-compose/#1","text":"Cree un docker-compose.yml para levantar una aplicaci\u00f3n tomcat de ejemplo Sample Application Basados en la imagen tomcat que escucha en el puerto 8080 Referencias: https://docs.docker.com/compose/overview/ https://docs.docker.com/compose/compose-file/compose-file-v2/","title":"1."},{"location":"chapter06/","text":"Multiple contenedores Ejecutar dos containers vinculados $ docker image pull mariadb:latest $ docker container run -p 3306:3306 \\ --name mysql \\ -e MYSQL_ROOT_PASSWORD=pass123 \\ -d mariadb:latest $ docker image pull nimmis/apache-php5 $ docker container run -d \\ -p 80:80 \\ --name apache2 \\ --link mysql \\ nimmis/apache-php5 $ docker exec -it apache2 bash -c \\ \"echo '<?php phpinfo() ?>' > /var/www/html/test.php\" $ curl http://localhost/test.php $ docker exec -it apache2 /bin/bash /# apt-get update && apt-get install -y mysql-client /# mysql -u root -ppass123 -h mysql mkdir -p wp/database wp/html; cd wp docker run \\ -e MYSQL_ROOT_PASSWORD=rootpass \\ -e MYSQL_DATABASE=wordpress \\ --name wordpressdb \\ -v \"$PWD/database\":/var/lib/mysql \\ -d mariadb:latest docker run \\ -e WORDPRESS_DB_PASSWORD=rootpass \\ --name wordpress \\ --link wordpressdb:mysql \\ -p 8082:80 \\ -v \"$PWD/html\":/var/www/html \\ -d wordpress","title":"Multiple contenedores"},{"location":"chapter06/#multiple-contenedores","text":"Ejecutar dos containers vinculados $ docker image pull mariadb:latest $ docker container run -p 3306:3306 \\ --name mysql \\ -e MYSQL_ROOT_PASSWORD=pass123 \\ -d mariadb:latest $ docker image pull nimmis/apache-php5 $ docker container run -d \\ -p 80:80 \\ --name apache2 \\ --link mysql \\ nimmis/apache-php5 $ docker exec -it apache2 bash -c \\ \"echo '<?php phpinfo() ?>' > /var/www/html/test.php\" $ curl http://localhost/test.php $ docker exec -it apache2 /bin/bash /# apt-get update && apt-get install -y mysql-client /# mysql -u root -ppass123 -h mysql mkdir -p wp/database wp/html; cd wp docker run \\ -e MYSQL_ROOT_PASSWORD=rootpass \\ -e MYSQL_DATABASE=wordpress \\ --name wordpressdb \\ -v \"$PWD/database\":/var/lib/mysql \\ -d mariadb:latest docker run \\ -e WORDPRESS_DB_PASSWORD=rootpass \\ --name wordpress \\ --link wordpressdb:mysql \\ -p 8082:80 \\ -v \"$PWD/html\":/var/www/html \\ -d wordpress","title":"Multiple contenedores"}]}